

@article{Altenkirch2015-yl,
  title     = {Indexed containers},
  author    = {Altenkirch, Thorsten and Ghani, Neil and Hancock, Peter and
               Mcbride, Conor and Morris, Peter},
  abstract  = {We show that the syntactically rich notion of strictly positive
               families can be reduced to a core type theory with a fixed
               number of type constructors exploiting the novel notion of
               indexed containers. As a result, we show indexed containers
               provide normal forms for strictly positive families in much the
               same way that containers provide normal forms for strictly
               positive types. Interestingly, this step from containers to
               indexed containers is achieved without having to extend the core
               type theory. Most of the construction presented here has been
               formalized using the Agda system.},
  journal   = {J. Funct. Programming},
  publisher = {Cambridge University Press},
  volume    = 25,
  pages     = {e5},
  month     = jan,
  year      = 2015
}

@inproceedings{Boulier2017-cm,
  title     = {The next 700 syntactical models of type theory},
  booktitle = {Proceedings of the 6th {ACM} {SIGPLAN} Conference on Certified
               Programs and Proofs},
  author    = {Boulier, Simon and P{\'e}drot, Pierre-Marie and Tabareau,
               Nicolas},
  abstract  = {A family of syntactic models for the calculus of construction
               with universes (CC$\omega$) is described, all of them preserving
               conversion of the calculus definitionally, and thus giving rise
               directly to a program transformation of CC$\omega$ into itself.
               Those models are based on the remark that negative type
               constructors (e.g. dependent product, coinductive types or
               universes) are underspecified in type theory-which leaves some
               freedom on extra intensional specifications. The model
               construction can be seen as a compilation phase from a complex
               type theory into a simpler type theory. Such models can be used
               to derive (the negative part of) independence results with
               respect to CC$\omega$, such as functional extensionality,
               propositional extensionality, univalence or the fact that
               bisimulation on a coinductive type may not coincide with
               equality. They can also be used to add new principles to the
               theory, which we illustrate by defining a version of CC$\omega$
               with ad-hoc polymorphism that shows in particular that
               parametricity is not an implicit requirement of type theory. The
               correctness of some of the models/program transformations have
               been checked in the Coq proof assistant and have been
               instrumented as a Coq plugin.},
  publisher = {Association for Computing Machinery},
  pages     = {182--194},
  series    = {CPP 2017},
  month     = jan,
  year      = 2017,
  address   = {New York, NY, USA},
  keywords  = {Dependent type theory, Program translation},
  location  = {Paris, France}
}

@article{Boulier2018-zy,
  title    = {Extending type theory with syntactic models},
  author   = {Boulier, S},
  abstract = {This thesis is about the metatheory of intuitionnistic type
              theory. The considered systems are variants of Martin-Lof type
              theory of Calculus of Constructions, and we are interested in the
              coherence of those systems and in the independence of axioms with
              respect to those systems. The common theme of this thesis is the
              construction of syntactic models, which are models reusing type
              theory to interpret type theory. In a first part, we introduce
              type theory by a minimal system and several possible extensions.
              In a second part, we introduce the syntactic models given by
              program translation and give several examples. In a third part,
              we present Template-Coq, a plugin for metaprogramming in Coq. We
              demonstrate how to use it to implement directly some syntactic
              models. Last, we consider type theories with two equalities: one
              strict and one univalent. We propose a re-reading of works of
              Coquand et.al. and of Orton and Pitts on the cubical model by
              introducing degenerate fibrancy.},
  month    = nov,
  year     = 2018
}

@article{Hewer2024-cc,
  title     = {Quotient Haskell: Lightweight Quotient Types for All},
  author    = {Hewer, Brandon and Hutton, Graham},
  abstract  = {Subtypes and quotient types are dual type abstractions. However,
               while subtypes are widely used both explicitly and implicitly,
               quotient types have not seen much practical use outside of proof
               assistants. A key difficulty to wider adoption of quotient types
               lies in the significant burden of proof-obligations that arises
               from their use. In this article, we address this issue by
               introducing a class of quotient types for which the
               proof-obligations are decidable by an SMT solver. We demonstrate
               this idea in practice by presenting Quotient Haskell, an
               extension of Liquid Haskell with support for quotient types.},
  journal   = {Proc. ACM Program. Lang.},
  publisher = {Association for Computing Machinery},
  volume    = 8,
  number    = {POPL},
  pages     = {785--815},
  month     = jan,
  year      = 2024,
  address   = {New York, NY, USA},
  keywords  = {quotient types, refinement types, static verification}
}

@inproceedings{Viera2006-xq,
  title     = {A multi-stage language with intensional analysis},
  booktitle = {{GPCE} '06: Proceedings of the 5th International Conference on
               Generative Programming and Component Engineering},
  author    = {Viera, Marcos and Pardo, Alberto},
  abstract  = {This paper presents the definition of a language with reflection
               primitives. The language is a homogeneous multi-stage language
               that provides the capacity of code analysis by the inclusion of
               a pattern matching mechanism that permits inspection of the
               structure of quoted expressions and their destruction into
               component subparts. Quoted expressions include an explicit
               annotation of their context which is used for dynamic inference
               of type, where a dynamic typing discipline based on Hinze and
               Cheney's approach is used for typing quoted expressions.This
               paper follows the approach of Sheard and Pasalic about the use
               of the meta-language $\Omega$mega as a tool for language design.
               In this sense, it is shown how to represent the syntax, the
               static as well as the dynamic semantics of the proposed language
               in terms of $\Omega$mega constructs.},
  publisher = {unknown},
  month     = oct,
  year      = 2006
}

@article{Kovacs2022-vb,
  title         = {Staged compilation with two-level type theory},
  author        = {Kov{\'a}cs, Andr{\'a}s},
  abstract      = {The aim of staged compilation is to enable metaprogramming
                   in a way such that we have guarantees about the
                   well-formedness of code output, and we can also mix together
                   object-level and meta-level code in a concise and convenient
                   manner. In this work, we observe that two-level type theory
                   (2LTT), a system originally devised for the purpose of
                   developing synthetic homotopy theory, also serves as a
                   system for staged compilation with dependent types. 2LTT has
                   numerous good properties for this use case: it has a concise
                   specification, well-behaved model theory, and it supports a
                   wide range of language features both at the object and the
                   meta level. First, we give an overview of 2LTT's features
                   and applications in staging. Then, we present a staging
                   algorithm and prove its correctness. Our algorithm is
                   ``staging-by-evaluation'', analogously to the technique of
                   normalization-by-evaluation, in that staging is given by the
                   evaluation of 2LTT syntax in a semantic domain. The staging
                   algorithm together with its correctness constitutes a proof
                   of strong conservativity of 2LLT over the object theory. To
                   our knowledge, this is the first description of staged
                   compilation which supports full dependent types and
                   unrestricted staging for types.},
  month         = sep,
  year          = 2022,
  archiveprefix = {arXiv},
  primaryclass  = {cs.PL},
  eprint        = {2209.09729}
}

@article{Yallop2017-cg,
  title     = {Staged generic programming},
  author    = {Yallop, Jeremy},
  abstract  = {Generic programming libraries such as Scrap Your Boilerplate
               eliminate the need to write repetitive code, but typically
               introduce significant performance overheads. This leaves
               programmers with the regrettable choice between writing succinct
               but slow programs and writing tedious but efficient programs.
               Applying structured multi-stage programming techniques
               transforms Scrap Your Boilerplate from an inefficient library
               into a typed optimising code generator, bringing its performance
               in line with hand-written code, and so combining high-level
               programming with uncompromised performance.},
  journal   = {Proc. ACM Program. Lang.},
  publisher = {Association for Computing Machinery},
  volume    = 1,
  number    = {ICFP},
  pages     = {1--29},
  month     = aug,
  year      = 2017,
  address   = {New York, NY, USA},
  keywords  = {generic programming, metaprogramming, multi-stage programming,
               partial evaluation}
}

@article{Castellan2019-sh,
  title         = {Categories with Families: Unityped, Simply Typed, and
                   Dependently Typed},
  author        = {Castellan, Simon and Clairambault, Pierre and Dybjer, Peter},
  abstract      = {We show how the categorical logic of untyped, simply typed
                   and dependently typed lambda calculus can be structured
                   around the notion of category with family (cwf). To this end
                   we introduce subcategories of simply typed cwfs (scwfs),
                   where types do not depend on variables, and unityped cwfs
                   (ucwfs), where there is only one type. We prove several
                   equivalence and biequivalence theorems between cwf-based
                   notions and basic notions of categorical logic, such as
                   cartesian operads, Lawvere theories, categories with finite
                   products and limits, cartesian closed categories, and
                   locally cartesian closed categories. Some of these theorems
                   depend on the restrictions of contextuality (in the sense of
                   Cartmell) or democracy (used by Clairambault and Dybjer for
                   their biequivalence theorems). Some theorems are
                   equivalences between notions with strict preservation of
                   chosen structure. Others are biequivalences between notions
                   where properties are only preserved up to isomorphism. In
                   addition to this we discuss various constructions of initial
                   ucwfs, scwfs, and cwfs with extra structure.},
  month         = apr,
  year          = 2019,
  archiveprefix = {arXiv},
  primaryclass  = {cs.LO},
  eprint        = {1904.00827}
}

@misc{Yallop_undated-sh,
  title        = {Unembedding {Domain-Specific} Languages},
  author       = {Yallop, Robert Atkey Sam Lindley},
  howpublished = {\url{https://bentnib.org/unembedding.pdf}},
  note         = {Accessed: 2024-2-22}
}

@article{Sato2001-ap,
  title   = {A simply typed context calculus with first-class environments},
  author  = {Sato, M and Sakurai, Takafumi and Kameyama, Yukiyoshi},
  journal = {J. Funct. Log. Prog.},
  pages   = {359--374},
  month   = mar,
  year    = 2001
}

@article{Brady2010-sf,
  title     = {Scrapping your inefficient engine: using partial evaluation to
               improve domain-specific language implementation},
  author    = {Brady, Edwin C and Hammond, Kevin},
  abstract  = {Partial evaluation aims to improve the efficiency of a program
               by specialising it with respect to some known inputs. In this
               paper, we show that partial evaluation can be an effective and,
               unusually, easy to use technique for the efficient
               implementation of embedded domain-specific languages. We achieve
               this by exploiting dependent types and by following some simple
               rules in the definition of the interpreter for the
               domain-specific language. We present experimental evidence that
               partial evaluation of programs in domain-specific languages can
               yield efficient residual programs whose performance is
               competitive with their Java and C equivalents and which are
               also, through the use of dependent types, verifiably
               resource-safe. Using our technique, it follows that a verifiably
               correct and resource-safe program can also be an efficient
               program},
  journal   = {SIGPLAN Not.},
  publisher = {Association for Computing Machinery},
  volume    = 45,
  number    = 9,
  pages     = {297--308},
  month     = sep,
  year      = 2010,
  address   = {New York, NY, USA},
  keywords  = {dependent types, partial evaluation}
}


@article{Annenkov2017-pd,
  title         = {{Two-Level} Type Theory and Applications},
  author        = {Annenkov, Danil and Capriotti, Paolo and Kraus, Nicolai and
                   Sattler, Christian},
  abstract      = {We define and develop two-level type theory (2LTT), a
                   version of Martin-L\textbackslash``of type theory which
                   combines two different type theories. We refer to them as
                   the inner and the outer type theory. In our case of
                   interest, the inner theory is homotopy type theory (HoTT)
                   which may include univalent universes and higher inductive
                   types. The outer theory is a traditional form of type theory
                   validating uniqueness of identity proofs (UIP). One point of
                   view on it is as internalised meta-theory of the inner type
                   theory. There are two motivations for 2LTT. Firstly, there
                   are certain results about HoTT which are of meta-theoretic
                   nature, such as the statement that semisimplicial types up
                   to level $n$ can be constructed in HoTT for any externally
                   fixed natural number $n$. Such results cannot be expressed
                   in HoTT itself, but they can be formalised and proved in
                   2LTT, where $n$ will be a variable in the outer theory. This
                   point of view is inspired by observations about
                   conservativity of presheaf models. Secondly, 2LTT is a
                   framework which is suitable for formulating additional
                   axioms that one might want to add to HoTT. This idea is
                   heavily inspired by Voevodsky's Homotopy Type System (HTS),
                   which constitutes one specific instance of a 2LTT. HTS has
                   an axiom ensuring that the type of natural numbers behaves
                   like the external natural numbers, which allows the
                   construction of a universe of semisimplicial types. In 2LTT,
                   this axiom can be stated simply be asking the inner and
                   outer natural numbers to be isomorphic. After defining 2LTT,
                   we set up a collection of tools with the goal of making 2LTT
                   a convenient language for future developments. As a first
                   such application, we develop the theory of Reedy fibrant
                   diagrams in the style of Shulman. Continuing this line of
                   thought, we suggest a definition of (infinity,1)-category
                   and give some examples.},
  month         = may,
  year          = 2017,
  archiveprefix = {arXiv},
  primaryclass  = {cs.LO},
  eprint        = {1705.03307}
}

@inproceedings{Taha1997-ag,
  title     = {Multi-stage programming with explicit annotations},
  booktitle = {Proceedings of the 1997 {ACM} {SIGPLAN} symposium on Partial
               evaluation and semantics-based program manipulation},
  author    = {Taha, Walid and Sheard, Tim},
  abstract  = {We introduce MetaML, a statically-typed multi-stage programming
               language extending Nielson and Nielson's two stage notation to
               an arbitrary number of stages. MetaML extends previous work by
               introducing four distinct staging annotations which generalize
               those published previously [25, 12, 7, 6]We give a static
               semantics in which type checking is done once and for all before
               the first stage, and a dynamic semantics which introduces a new
               concept of cross-stage persistence, which requires that
               variables available in any stage are also available in all
               future stages.We illustrate that staging is a manual form of
               binding time analysis. We explain why, even in the presence of
               automatic binding time analysis, explicit annotations are
               useful, especially for programs with more than two stages.A
               thesis of this paper is that multi-stage languages are useful as
               programming languages in their own right, and should support
               features that make it possible for programmers to write staged
               computations without significantly changing their normal
               programming style. To illustrate this we provide a simple three
               stage example, and an extended two-stage example elaborating a
               number of practical issues.},
  publisher = {Association for Computing Machinery},
  pages     = {203--217},
  series    = {PEPM '97},
  month     = dec,
  year      = 1997,
  address   = {New York, NY, USA},
  location  = {Amsterdam, The Netherlands}
}


@article{Uemura2019-cc,
  title    = {A General Framework for the Semantics of Type Theory},
  author   = {Uemura, Taichi},
  abstract = {We propose an abstract notion of a type theory to unify the
              semantics of various type theories including
              Martin-L\textbackslash``\{o\}f type theory, two-level type theory
              and cubical type theory. We establish basic results in the
              semantics of type theory: every type theory has a bi-initial
              model; every model of a type theory has its internal language;
              the category of theories over a type theory is bi-equivalent to a
              full sub-2-category of the 2-category of models of the type
              theory.},
  journal  = {arXiv [math.CT]},
  month    = apr,
  year     = 2019
}


@article{Awodey2014-hh,
  title         = {Natural models of homotopy type theory},
  author        = {Awodey, Steve},
  abstract      = {The notion of a natural model of type theory is defined in
                   terms of that of a representable natural transfomation of
                   presheaves. It is shown that such models agree exactly with
                   the concept of a category with families in the sense of
                   Dybjer, which can be regarded as an algebraic formulation of
                   type theory. We determine conditions for such models to
                   satisfy the inference rules for dependent sums, dependent
                   products, and intensional identity types, as used in
                   homotopy type theory. It is then shown that a category
                   admits such a model if it has a class of maps that behave
                   like the abstract fibrations in axiomatic homotopy theory:
                   they should be stable under pullback, closed under
                   composition and relative products, and there should be
                   weakly orthogonal factorizations into the class. It follows
                   that many familiar settings for homotopy theory also admit
                   natural models of the basic system of homotopy type theory.},
  month         = jun,
  year          = 2014,
  archiveprefix = {arXiv},
  primaryclass  = {math.CT},
  eprint        = {1406.3219}
}


@article{Baudon2023-cy,
  title     = {{Bit-Stealing} Made Legal: Compilation for Custom Memory
               Representations of Algebraic Data Types},
  author    = {Baudon, Tha{\"\i}s and Radanne, Gabriel and Gonnord, Laure},
  abstract  = {Initially present only in functional languages such as OCaml and
               Haskell, Algebraic Data Types (ADTs) have now become pervasive
               in mainstream languages, providing nice data abstractions and an
               elegant way to express functions through pattern matching.
               Unfortunately, ADTs remain seldom used in low-level programming.
               One reason is that their increased convenience comes at the cost
               of abstracting away the exact memory layout of values. Even
               Rust, which tries to optimize data layout, severely limits
               control over memory representation. In this article, we present
               a new approach to specify the data layout of rich data types
               based on a dual view: a source type, providing a high-level
               description available in the rest of the code, along with a
               memory type, providing full control over the memory layout. This
               dual view allows for better reasoning about memory layout, both
               for correctness, with dedicated validity criteria linking the
               two views, and for optimizations that manipulate the memory
               view. We then provide algorithms to compile constructors and
               destructors, including pattern matching, to their low-level
               memory representation. We prove our compilation algorithms
               correct, implement them in a tool called ribbit that compiles to
               LLVM IR, and show some early experimental results.},
  journal   = {Proc. ACM Program. Lang.},
  publisher = {Association for Computing Machinery},
  volume    = 7,
  number    = {ICFP},
  pages     = {813--846},
  month     = aug,
  year      = 2023,
  address   = {New York, NY, USA},
  keywords  = {Algebraic Data Types, Compilation, Data Layouts, Pattern
               Matching}
}

@inproceedings{Hinze2011-jx,
  title     = {Type Fusion},
  booktitle = {Algebraic Methodology and Software Technology},
  author    = {Hinze, Ralf},
  abstract  = {Fusion is an indispensable tool in the arsenal of techniques for
               program derivation. Less well-known, but equally valuable is
               type fusion, which states conditions for fusing an application
               of a functor with an initial algebra to form another initial
               algebra. We provide a novel proof of type fusion based on
               adjoint folds and discuss several applications: type
               firstification, type specialisation and tabulation.},
  publisher = {Springer Berlin Heidelberg},
  pages     = {92--110},
  year      = 2011
}

@inproceedings{Shao1994-kp,
  title     = {Unrolling lists},
  booktitle = {Proceedings of the 1994 {ACM} conference on {LISP} and
               functional programming},
  author    = {Shao, Zhong and Reppy, John H and Appel, Andrew W},
  abstract  = {Lists are ubiquitous in functional programs, thus supporting
               lists efficiently is a major concern to compiler writers for
               functional languages. Lists are normally represented as linked
               cons cells, with each cons cell containing a car (the data) and
               a cdr (the link); this is inefficient in the use of space,
               because 50\% of the storage is used for links. Loops and
               recursions on lists are slow on modern machines because of the
               long chains of control dependencies (in checking for nil) and
               data dependencies (in fetching cdr fields).We present a data
               structure for ``unrolled lists'', where each cell has several
               data items (car fields) and one link (cdr). This reduces the
               memory used for links, and it significantly shortens the length
               of control-dependence and data-dependence chains in operations
               on lists.We further present an efficient compile-time analysis
               that transforms programs written for ``ordinary'' lists into
               programs on unrolled lists. The use of our new representation
               requires no change to existing programs.We sketch the proof of
               soundness of our analysis---which is based on refinement
               types---and present some preliminary measurements of our
               technique.},
  publisher = {Association for Computing Machinery},
  pages     = {185--195},
  series    = {LFP '94},
  month     = jul,
  year      = 1994,
  address   = {New York, NY, USA},
  location  = {Orlando, Florida, USA}
}

@misc{Kaposi2020-is,
  title     = {A syntax for mutual inductive families},
  author    = {Kaposi, Ambrus and von Raumer, Jakob},
  abstract  = {Inductive families of types are a feature of most languages
               based on dependent types. They are usually described either by
               syntactic schemes or by encodings of strictly positive functors
               such as combinator languages or containers. The former
               approaches are informal and give only external signatures, the
               latter approaches suffer from encoding overheads and do not
               directly represent mutual types. In this paper we propose a
               direct method for describing signatures for mutual inductive
               families using a domain-specific type theory. A signature is a
               context (roughly speaking, a list of types) in this small type
               theory. Algebras, displayed algebras and sections are defined by
               models of this type theory: the standard model, the logical
               predicate and a logical relation interpretation, respectively.
               We reduce the existence of initial algebras for these signatures
               to the existence of the syntax of our domain-specific type
               theory. As this theory is very simple, its normal syntax can be
               encoded using indexed W-types. To the best of our knowledge,
               this is the first formalisation of the folklore fact that mutual
               inductive types can be reduced to indexed W-types. The contents
               of this paper were formalised in the proof assistant Agda.},
  publisher = {Schloss Dagstuhl - Leibniz-Zentrum f{\"u}r Informatik},
  month     = jun,
  year      = 2020
}


@inproceedings{Allais2023-pf,
  title     = {Builtin Types Viewed as Inductive Families},
  booktitle = {Programming Languages and Systems},
  author    = {Allais, Guillaume},
  abstract  = {State of the art optimisation passes for dependently typed
               languages can help erase the redundant information typical of
               invariant-rich data structures and programs. These automated
               processes do not dramatically change the structure of the data,
               even though more efficient representations could be available.},
  publisher = {Springer Nature Switzerland},
  pages     = {113--139},
  year      = 2023
}

@article{Allais2023-zq,
  title         = {Seamless, Correct, and Generic Programming over Serialised
                   Data},
  author        = {Allais, Guillaume},
  abstract      = {In typed functional languages, one can typically only
                   manipulate data in a type-safe manner if it first has been
                   deserialised into an in-memory tree represented as a graph
                   of nodes-as-structs and subterms-as-pointers. We demonstrate
                   how we can use QTT as implemented in \textbackslashidris\{\}
                   to define a small universe of serialised datatypes, and
                   provide generic programs allowing users to process values
                   stored contiguously in buffers. Our approach allows
                   implementors to prove the full functional correctness by
                   construction of the IO functions processing the data stored
                   in the buffer.},
  month         = oct,
  year          = 2023,
  archiveprefix = {arXiv},
  primaryclass  = {cs.PL},
  eprint        = {2310.13441}
}


@article{Dybjer1994-zx,
  title     = {Inductive families},
  author    = {Dybjer, Peter},
  abstract  = {A general formulation of inductive and recursive definitions in
               Martin-L{\"o}f's type theory is presented. It extends
               Backhouse's `Do-It-Yourself Type Theory' to include inductive
               definitions of families of sets and definitions of functions by
               recursion on the way elements of such sets are generated. The
               formulation is in natural deduction and is intended to be a
               natural generalisation to type theory of Martin-L{\"o}f's theory
               of iterated inductive definitions in predicate logic. Formal
               criteria are given for correct formation and introduction rules
               of a new set former capturing definition by strictly positive,
               iterated, generalised induction. Moreover, there is an inversion
               principle for deriving elimination and equality rules from the
               formation and introduction rules. Finally, there is an
               alternative schematic presentation of definition by recursion.
               The resulting theory is a flexible and powerful language for
               programming and constructive mathematics. We hint at the wealth
               of possible applications by showing several basic examples:
               predicate logic, generalised induction, and a formalisation of
               the untyped lambda calculus.},
  journal   = {Form. Asp. Comput.},
  publisher = {Association for Computing Machinery},
  volume    = 6,
  number    = 4,
  pages     = {440--465},
  month     = jan,
  year      = 1994
}

