\section{Related work}

Using inductive types as a form of abstraction was first explored by Wadler
\cite{Wadler1987-zp} through \emph{views}. The extension to dependent types
was developed by McBride and McKinna \cite{Mcbride2004-fd}, as part of the
Epigram project. Our system differs from views in the computational content
of the abstraction; even with deforestation \cite{Wadler1990-yo} views are not
always zero-cost, but representations are.
Atkey \cite{Atkey2011-ex} shows how to generically derive inductive types which
are refinements of other inductive types. This work could be integrated in our
system to automatically generate representations for refined data types.
Zero-cost data reuse when it comes to refinements of inductive types has been
explored in the context of Church encoding in Cedille \cite{Diehl2018-ba}, but
does not extend to custom representations.

Work by Allais \cite{Allais2023-pf,Allais2023-zq} uses a combination of views,
erasure by quantitative type theory, and universes of flattened data types to
achieve performance improvements when working with serialised data in Idris 2.
Our approach differs because we have access to `native' data representations, so
we do not need to rely on encodings. Additionally, they rely on heuristic
compiler optimisations to erase their views. On the topic of memory layout
optimisation, Baudon \cite{Baudon2023-cy} develops Ribbit, a DSL for the
specification of the memory representation of algebraic data types, which can
specify techniques like struct packing and bit-stealing. To our knowledge
however, this does not provide control over the indirection introduced by
\emph{inductive} types.

Dependently typed languages with extraction features, notably Coq
\cite{coq-extraction} and Agda \cite{agda-extraction}, have some overlapping
capabilities with our approach, but they do not provide any of the correctness
guarantees. Optimisation tricks such as the Nat-hack, and its generalisation to
other types, can emulate a part of our system but are unverified and special
casing in the compiler. Since the extended abstract version of this paper, an
optimisation was merged into Idris 2 \cite{idris-pr} to erase the forgetful and
recomputation functions for reindexing list/maybe/number-like types.
There also seems to be a demand for this kind of optimisation in Agda
\cite{agda-issue}.

% We hope
% that this work will inspire similar optimisations in other dependently typed
% languages, for which there seems to be a demand.

\section{Future work}

% We could also
% formalise the relationship between inductive families in $\lambdaind$ and the
% standard formulation in terms of $W$-types \cite{Abbott2004-va}.

In the future we aim to expand the class of theories we consider, to include
quotient-induction, induction-induction and induction-recursion. Representations
for quotient-inductive types in particular could give rise to ergonomic ways of
computing with more `traditional' data structures such as hash maps or binary
search trees. We could program inductively over these structures but extract
programs without redundancy in data representation.

% We could also look into automating the discovery of inductive algebras for
% `known' classes of data types through metaprogramming \cite{Dagand2017-nj}. This
% could reproduce optimisation techniques by modern proof assistants but as
% part of a standard library, with accompanying internal correctness proofs. It
% could also extend to identity function detection, by internalising the
% extraction step explored in \cref{sub:irr}.

There are elements of our formalisation which should be developed further. We
did not formulate decidability of equality and normalisation for $\lambdadata$,
which is needed for typechecking. We have implemented a
normalisation-by-evaluation \cite{Altenkirch2020-rm} algorithm used in the
implementation of \superfluid, but have only sketched that it has the
desired properties.

We would like to further explore the relationship of the $\mta{Repr}$ modality with
general systems for defining modalities, such as \emph{multi-modal type theory}
by Gratzer \cite{Gratzer2020-kf}. Additionally, we expect that metaprogramming with
representations is most naturally done in the context of \emph{two-level type theory}
\cite{Kovacs2022-vb}. We would like to explore the embedding of $\lambdadata$
in a two-level type theory, where signatures become types in the meta-fragment.
Then we could develop various methods of generating representations internally,
for example through algebraic ornaments, without needing to laboriously prove
induction principles by hand.

\section{Conclusion}

This paper addresses some of the inefficiencies of inductive families in
dependently typed languages by introducing custom runtime representations that
preserve logical guarantees and simplicity of the surface language while
optimising performance and usability. These representations are formalised as inductive
algebras, and come with a framework for reasoning about them: provably zero-cost
conversions between original and represented data.
The compilation process guarantees erasure of abstraction layers, translating
high-level constructs to their defined implementations. Our hope is that by
decoupling logical structure from runtime representation, ergonomic type-driven
correctness can be leveraged without sacrificing performance.


\subsubsection{Acknowledgements}
We would like to thank the anonymous reviewers for their feedback that
significantly improved the quality of this paper. Additionally, we would like to
thank Guillaume Allais for helpful comments on an earlier version of this paper,
as well as Nathan Corbyn, Ellis Kesterton, and Matthew Pickering for interesting
discussions on algebraic theories, ergonomics of inductive types, and pattern
synonyms.
