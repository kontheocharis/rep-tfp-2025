\section{Elaboration into a core staged language}\label{sec:elaboration}

The elaboration procedure $\Crepr{} : \lambdarep \to \lambdaprim$ is still left
to be defined. The goal of this procedure is to eliminate inductive constructs
through the defined representations, yielding the final program that can be
staged and compiled. To define $\Crepr{}$, we first need to introduce a concept
of \emph{concrete signatures}. A concrete signature is a signature where all
items are accompanied by representations. In other words, $\Sigma$ is a
concrete signature when
\begin{itemize}
  \item if $\Sdata{D}{\Delta} \in \Sigma$, then $\exists A \, \vec{x} .\
          \Srepr{D}{\vec{x}}{A} \in \Sigma$,
  \item if $\Sctorvar{\lab{C}}{\Delta_{\lab{C}}}{D}{\Delta} \in \Sigma$, then $\exists
          t\,\vec{z} .\ \Sreprvar{\lab{C}}{\vec{z}}{t} \in \Sigma$,
  \item if $\Sclosed{\lab{D}}{\vec{\lab{C}}} \in \Sigma$, then $\exists
          T\,\vec{a}\,\eta\,\vec{m} .\ \Srepr{\caselab{D}}{T\,\vec{a}\,\eta\,\vec{m} }{e}
          \in \Sigma$, and
  \item if $\Sdef{f}{M}{m} \in \Sigma$, then $\exists a .\ \Sreprconst{f}{a} \in
          \Sigma$.
\end{itemize}
A term or type can only be elaborated if the signature it is well formed in is
concrete. This is a restriction that ensures that the elaboration procedure
can always look up the representation of a data item, constructor or definition.
We can now define the elaboration $\Crepr{}$ for types and terms in a concrete
signature. The definition of $\Crepr{}$ is given in a mutually recursive
CWF-style presentation, mapping constructs in $\lambdarep$ to $\lambdaprim$.
More specifically, we define $\Crepr{}$ as mapping contexts, types, and terms in \todo{And substitutions!}
$\lambdarep$, to contexts, types, and terms in $\lambdaprim$, respectively.

\begin{figure}[H]
  \[
    \begin{array}[t]{ccc}
      % \begin{array}[t]{ll}
      \begin{aligned}[t]
         & \Crepr{}          : \Con_{\lang{rep}} \ \Sigma  \to \Con_{\lang{prim}} \\
         & \Crepr{(\cdot)}     = \cdot                                            \\
         & \Crepr{(\Gamma, T)} = \Crepr{\Gamma}, \Crepr{T}
      \end{aligned}                                             & \quad
      % \begin{aligned}[t]
      %    & \Crepr{}          : \ \Tel_i \ \Sigma \ \Gamma  \to \ \Tel_i \ \Sigma\ \Crepr{\Gamma} \\
      %    & \Crepr{(\cdot)}     = \cdot                                                           \\
      %    & \Crepr{(\Delta, T)} = \Crepr{\Delta}, \Crepr{T}
      % \end{aligned}
      % \end{array} \\
      % \begin{array}[t]{ll}
      \begin{aligned}[t]
         & \Crepr{}          : \Ty_{\lang{rep},i} \ \Sigma \ \Gamma  \to \Ty_{{\lang{prim}},i} \ \Crepr{\Gamma} \\
         & \Crepr{(\lab{D}\,\vec{t})}     = \lift{ \Crepr{A_{\lab{D}}} [\crepr{\vec{t}}] }                      \\
         & \text{else recurse with $\Crepr{}$}                                                                  \\
      \end{aligned} \quad &
      \begin{aligned}[t]
         & \Crepr{}          : \Tm_{\lang{rep},i} \ \Sigma \ \Gamma \ T  \to \Tm_{\lang{prim},i} \ \Crepr{\Gamma} \ \Crepr{T} \\
         & \Crepr{(\lab{C}\,\vec{t})}     = \quot{\Crepr{(\pi_1\, t_{\lab{C}})} [\Crepr{\vec{t}}]}                            \\
         & \Crepr{(\caselab{D}\,\eta\,\vec{m})}     = \quot{\Crepr{e_{\lab{C}}} [\wildp,\wildp,\Crepr{\eta},\Crepr{\vec{m}}]} \\
         & \Crepr{\lab{f}}     = \pi_1\, a_{\lab{f}}                                                                          \\
         & \text{else recurse with $\Crepr{}$}                                                                                \\
      \end{aligned}
      % \end{array}
    \end{array}
  \]
  \caption{Definition of $\Crepr{}$, where $\Sigma$ is a concrete signature.}
  \label{fig:repr-rules}
\end{figure}

The elaboration of a type $\lab{D}\,\vec{t}$ is given by its defined
representation $A_{\lab{D}}$ applied to the elaborations of its arguments. The
elaboration of a constructor term $\lab{C}\,\vec{t}$ is given by its defined
representation $t_{\lab{C}}$ applied to the elaborations of its arguments.
Similarly, the elaboration of a closed eliminator term
$\caselab{D}\,\eta\,\vec{m}$ is given by its defined representation
$e_{\lab{C}}$ applied to the elaborations of its arguments. Finally, the
elaboration of a definition $\lab{f}$ is given by its defined representation
$a_{\lab{f}}$. Notice that for data types, constructors, and case expressions,
the representation terms themselves must be elaborated, since they are allowed
to reference other data types, constructors defined before them. The
elaboration procedure is type-preserving by construction, which means that if
$\Sigma \mid \Gamma \vdash_{\lang{rep}} t : T$, then $\Crepr{\Gamma}
  \vdash_{\lang{prim}} \Crepr{t} : \Crepr{T}$. \todo{We must also show that
  elaboration preserves the equality rules, which can be done through the extra
  proofs given in the representations!}

