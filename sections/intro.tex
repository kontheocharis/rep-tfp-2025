\section{Introduction}\label{sec:intro}

Dependently-typed functional languages offer high-level expressiveness, but
unlike imperative languages such as C, they limit control in behaviour of
programs when it comes to runtime execution. Indeed, this is intentional; by
letting go of low-level control, programs become easier to write, understand,
and modify. However, relinquishing this control often leads to unoptimised
programs that do not take full advantage of the architecture they are running
on. The default memory representation for inductive types is a linked tree,
where each constructor is a node and the recursive data it holds are the
children of that node. This representation is very flexible, because it can
represent any inductive data type, but it is not always the most efficient.

\subsection{The `Nat-hack'}

Introduce Nat-hack and detail how it works in Idris, Lean, Coq, etc.

Provide perf tests for Nat hack vs others

\subsection{Beyond natural numbers}

Identify other data structures that would benefit (list-like things, trees)

\subsection{A staging-based approach}

Staging and why is it needed?

\subsection{Contributions}

\begin{itemize}
  \item A type system $\lambda_{2+\text{Rep}}$ for defining data representations based
        in a staged language, in a correct-by-construction manner.
  \item An elaboration procedure from $\lambda_{2+\text{Rep}}$ to $\lambda_2$, which
        translates inductive data into the format defined by the representations.
  \item Application of this type system to define the `Nat-hack' in a principled way
        and show that it is correct.
  \item A further exploration of the type system, showing how to represent other
        inductive types such as lists and trees.
\end{itemize}
