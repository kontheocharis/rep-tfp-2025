\section{Introduction}\label{sec:intro}

Inductive families are a broad generalisation of inductive data types found in
most functional programming languages. Every inductive definition is equipped
with a eliminator that captures the notion of mathematical induction over the
data, and in particular, enables structural recursion over the data. This is a
powerful tool for programming as well as theorem proving.

However, this abstraction has a cost when it comes to compilation: the
runtime representation of inductive types is a linked tree structure. A list as
an inductively defined data structure is stored as a linked list on the heap,
and a natural number is stored as a unary number where each digit is an empty
heap cell. This representation is not always the most efficient for all
operations, and often forces users to rely on more efficient machine primitives
to achieve desirable performance. The `Nat-hack' in languages with dependent types is
a prime example of this, where natural numbers are represented as GMP-style big
integers for efficient arithmetic operations [CITE?].

This is not the only issue with the compilation of inductive families. Despite
advances in the erasure of irrelevant indices in inductive families
\cite{Brady2004-ay} and the use of theories with irrelevant fragments
\cite{Atkey2018-pj,Moon2021-eb,Abel2023-ey}, there is still a need to convert
between different indexed views of the same data. For example, the function to
convert from $\datalab{List}\ T$ to $\datalab{Vec}\ T\ n$ by forgetting the
length index $n$ is \emph{not} erased by any current language with dependent
types, unless vectors are defined as a refinement of lists with an erased length
field (which hurts dependent pattern matching due to the presence of
non-structural witnesses), or a Church encoding is used in a Curry-style context
\cite{Diehl2018-ba} (which restricts the flexibility of data representation).

Wadler's views \cite{Wadler1987-zp} provide a way to abstract over inductive
interfaces, so that different views of the same data can be defined and
converted between seamlessly. In the context of inductive families, views have
been used in Epigram \cite{Mcbride2004-fd} that utilise the index refinement
machinery of dependent pattern matching to avoid certain proof obligations with
eliminator-like constructs. While views exhibit a nice way to transport across a
bijection between the original data and the viewed data, they do not utilise
this bijection to erase the view from the program. Despite deforestation being
able to handle this erasure to some extent, it is not guaranteed to erase all
traces of the view from the program, and the optimisation is often difficult to
predict.

In this paper, we propose an extension to a core language with dependent types
and inductive families which allows programmers to define custom,
correct-by-construction data representations. This is done
through user-defined translations of the constructors and eliminators of an
inductive type to a concrete implementation, which form a bijective view of the
original data called a `representation'. Representations are defined internally
to the language, and require coherence properties that ensure a representation
defines an initial algebra for the endofunctor associated with the original
inductive family. We define a type- and equality-preserving translation from the
language with representations to a language without them, which provably erases
all inductive types with defined representations from the program.

The in the final version of the paper, we plan to contribute the following:
\begin{itemize}
  \item A dependent type system with inductive families $\lambdaind$,
    and its extension with representations $\lambdarep$.
  \item A formulation of common optimisations such as the `Nat-hack', and
      similar for other inductive types, as representations.
  \item A translation from $\lambdarep$ to $\lambdaind$ that erases all
    inductive types with representations from the program.
  \item An implementation of this system in \textsc{Superfluid}, a programming
    language with inductive types and dependent pattern matching.
\end{itemize}


TODO:

- primitive note
- impl!
