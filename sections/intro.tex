\section{Introduction}\label{sec:intro}

Inductive families are a generalisation of inductive data types found in some
programming languages with dependent types. Every inductive definition is
equipped with an eliminator that captures the notion of mathematical induction
over the data, and in particular, enables structural recursion over the data.
This is a powerful tool for programming as well as theorem proving. However,
this abstraction has a cost when it comes to compilation: the runtime
representation of inductive types is a linked tree structure. This
representation is not always the most efficient for all operations, and often
forces users to rely on more efficient machine primitives to achieve desirable
performance, at the cost of structural recursion and dependent pattern matching.
This is the first problem we aim to address in this paper.

Despite advances in the erasure of irrelevant indices in inductive families
\cite{Brady2004-ay} and the use of theories with irrelevant fragments
\cite{Atkey2018-pj,Moon2021-eb}, there is still a need to convert
between different indexed views of the same data. For example, the function to
convert from $\datalab{List}\ T$ to $\datalab{Vec}\ T\ n$ by forgetting the
length index $n$ is \emph{not} erased by any current language with dependent
types, unless vectors are defined as a refinement of lists with an erased length
field (which hinders dependent pattern matching due to the presence of
non-structural witnesses), or a Church encoding is used in a Curry-style context
\cite{Diehl2018-ba} (which restricts the flexibility of data representation).
This is the second problem we aim to address in this paper.

Wadler's views \cite{Wadler1987-zp} provide a way to abstract over inductive
interfaces, so that different views of the same data can be defined and
converted between seamlessly. In the context of inductive families, views have
been used in Epigram \cite{Mcbride2004-fd} that utilise the index refinement
machinery of dependent pattern matching to avoid certain proof obligations with
eliminator-like constructs. While views exhibit a nice way to transport across a
bijection between the original data and the viewed data, they do not utilise
this bijection to erase the view from the program. Despite deforestation
handling this erasure to some extent, it is not guaranteed to erase all traces
of the view from the program, and the optimisation might be difficult to
predict.

In this paper, we propose an extension $\lambdarep$ to a core language with
dependent types and inductive families $\lambdaind$, which allows programmers to
define custom, correct-by-construction data representations. This is done
through user-defined translations of the constructors and eliminators of an
inductive type to a concrete implementation, which form a bijective view of the
original data called a `representation'. Representations are defined internally
to the language, and require coherence properties that ensure a representation
is faithful to its the original inductive family. In the final version of
the paper, we plan to contribute the following:
\begin{itemize}
  \item A dependent type system with inductive families $\lambdaind$,
    and its extension by representations $\lambdarep$.
  \item A formulation of common optimisations such as the `Nat-hack', and
      similarly for other inductive types, as representations.
  \item A demonstration of zero-cost data reuse when reindexing by using representations.
  \item A translation from $\lambdarep$ to $\lambdaind$ that erases all
    inductive types with representations from the program.
  \item An implementation of this system and accompanying examples in
    \textsc{Superfluid}, a programming language with inductive types and
    dependent pattern matching.
\end{itemize}

