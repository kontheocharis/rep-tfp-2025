\section{Introduction}\label{sec:intro}

Inductive families are a broad generalisation of inductive data types found in
most functional programming languages. Every inductive definition is equipped
with a eliminator that captures the notion of mathematical induction over the
data, and in particular, enables structural recursion over the data. This is a
powerful tool for programming as well as theorem proving. However, this
abstraction has a cost when it comes to compilation: the runtime representation
of inductive types is a linked tree structure. This representation is not always
the most efficient for all operations, and often forces users to rely on more
efficient machine primitives to achieve desirable performance, at the cost of
structural recursion and dependent pattern matching. This is the first problem
we aim to address in this paper.

Despite advances in the erasure of irrelevant indices in inductive families
\cite{Brady2004-ay} and the use of theories with irrelevant fragments
\cite{Atkey2018-pj,Moon2021-eb,Abel2023-ey}, there is still a need to convert
between different indexed views of the same data. For example, the function to
convert from $\datalab{List}\ T$ to $\datalab{Vec}\ T\ n$ by forgetting the
length index $n$ is \emph{not} erased by any current language with dependent
types, unless vectors are defined as a refinement of lists with an erased length
field (which hinders dependent pattern matching due to the presence of
non-structural witnesses), or a Church encoding is used in a Curry-style context
\cite{Diehl2018-ba} (which restricts the flexibility of data representation).

Wadler's views \cite{Wadler1987-zp} provide a way to abstract over inductive
interfaces, so that different views of the same data can be defined and
converted between seamlessly. In the context of inductive families, views have
been used in Epigram \cite{Mcbride2004-fd} that utilise the index refinement
machinery of dependent pattern matching to avoid certain proof obligations with
eliminator-like constructs. While views exhibit a nice way to transport across a
bijection between the original data and the viewed data, they do not utilise
this bijection to erase the view from the program. Despite deforestation being
able to handle this erasure to some extent, it is not guaranteed to erase all
traces of the view from the program, and the optimisation might be difficult to
predict.

In this paper, we propose an extension $\lambdarep$ to a core language with
dependent types and inductive families $\lambdaind$, which allows programmers to
define custom, correct-by-construction data representations. This is done
through user-defined translations of the constructors and eliminators of an
inductive type to a concrete implementation, which form a bijective view of the
original data called a `representation'. Representations are defined internally
to the language, and require coherence properties that ensure a representation
is faithful to its the original inductive family. The in the final version of
the paper, we plan to contribute the following:
\begin{itemize}
  \item A dependent type system with inductive families $\lambdaind$,
    and its extension by representations $\lambdarep$.
  \item A formulation of common optimisations such as the `Nat-hack', and
      similarly for other inductive types, as representations.
  \item A demonstration of zero-cost data reuse when reindexing by using representations.
  \item A translation from $\lambdarep$ to $\lambdaind$ that erases all
    inductive types with representations from the program.
  \item An implementation of this system and accompanying examples in
    \textsc{Superfluid}, a programming language with inductive types and
    dependent pattern matching.
\end{itemize}


