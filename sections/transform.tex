\section{The transformation}\label{sec:prelim}

The technique for transforming inductive data types into custom data structures
will be phrased in the language of 2-level type theory (2LTT)
\cite{Kovacs2022-vb}.

\subsection{The 2-level type theory $\cat{G}$}

We will work in a 2LTT which we denote $\cat{G}$. The meta fragment of
$\cat{G}$ contains a universe hierarchy $\univ{\mta{Meta},i}$ of meta-level
types, and a single universe of values $\Uv$. Additionally, the universe
$\univ{\mta{Meta},0}$ has a subuniverse $\Ur$ of "representable" meta-level
types. We have
\[
  \univ{\mta{Meta},i} : \univ{\mta{Meta},i+1} \qquad \Ur : \univ{\mta{Meta},1} \qquad \Uv : \univ{\mta{Meta},0} \,.
\]

Any object type $A$ can be lifted to the meta-level as $\lift A : \Ur$, and any
object term $t : A$ can be lifted as $\quot t : \lift A$, similarly to the
original presentation of 2LTT \cite{Kovacs2022-vb}. Splicing also works in the
same way; if $t : \lift A$, then $\splice t : A$. Universe levels will be
implicit in the rest of this presentation, as they are orthogonal to its main
content.

\subsection{Inductive data types}

We allow inductive data types to be defined in the meta fragment of $\cat{G}$,
as inductive families. These exist as first-class citizens, and we follow the
syntactical approach of \cite{Kaposi2020-is} ...

The judgement for inductive types is $\isind{(S, c)}$, where $S \in \Ty_s$ and
$c \in \Con_p \, S$ are the type and constructor signatures of the inductive
type.

We have constructors and eliminators for inductive types in the meta fragment.

...

\subsection{Choice of representations}

Representable meta types, or inhabitants of $\Ur$, are meta types which can be
staged into the object level, but are not necessarily just lifted object types.
Indeed, lifting an object type is one way to acquire a representable meta type.
However, the more interesting way to do so is to attach a representation to a
meta-level type. This is captured by the rule
\[
  \infrule[Repr-Mu]{\Gamma \vdash \isind{A} \quad \Gamma \vdash \isrepr{P}{A}}
  {\Gamma \vdash A_R : \Ur} \,.
\]
It utilises a new judgement form $\isrepr{R}{A}$, which states that $R$ is a
representation of the fixpoint of $A$.

The rule for introducing representations is
\[
  \infrule[Repr-Intro]{
    \begin{gathered}
      \Gamma \vdash \isind{A} \quad
      \Gamma \vdash R_A : \Uv                                \\
      \Gamma \vdash c_A : A [\lift{R_A}] \to \Gen \, R_A \quad
      \Gamma \vdash i_A : \lift{R_A} \to \Gen \, A [\lift{R_A}]
    \end{gathered}
  }{\Gamma \vdash \isrepr{(R_A, c_A, i_A)}{A}} \,.
\]
It states that a representation is a triple of an object type $R_A$, a
\emph{collapsing} function $c_A$, and an \emph{inspecting} function $i_A$. The
notation $A[B]$ is defined by
\begin{align*}
   & \wildp[\wildp] : (\Um \to \Um) \to \Um                                 \\
   & A[B] =           \mu (\lambda X . \, \defin{Syntax} \, (A X) \, B) \,.
\end{align*}
where the \defin{Syntax} type family is defined by
\[
  \data{Syntax} \,(M : \Um)\,(N : \Um) = \defin{known} \, M \mid \defin{opaque} \, N \,.
\]
(update to match "ind" judgement)

The collapsing function is used to convert a partial syntactical representation
of a term of the inductive type $\mu A$ into a value of a chosen representation
type $R_A$.

The return type of the collapsing function is over the monad $\Gen$. This is
the code generation monad, first described in [Kovacs unpublished], which is
defined as
\[
  \data{Gen} \, (A : \Um) = \defin{unGen} \, (\{ R : \Uv \} \to (A \to \lift R) \to \lift R)
\]

The inspecting function is used to convert a value of the chosen representation
type $R_A$ into a partial syntactical representation of a term of the inductive
type $\mu A$.

