\section{The transformation}\label{sec:prelim}

The technique for transforming inductive data types into custom data structures
will be phrased in the language of 2-level type theory (2LTT)
\cite{Kovacs2022-vb}.

\subsection{The 2-level type theory $\cat{G}$}

We will work in a 2LTT which we denote $\cat{G}$. The meta fragment of
$\cat{G}$ contains a universe hierarchy $\univ{\mta{Meta},i}$ of meta-level
types, and a single universe of values $\Uv$. Additionally, the universe
$\univ{\mta{Meta},0}$ has a subuniverse $\Ur$ of "representable" meta-level
types. We have
\[
  \univ{\mta{Meta},i} : \univ{\mta{Meta},i+1} \qquad \Ur : \univ{\mta{Meta},1} \qquad \Uv : \univ{\mta{Meta},0} \,.
\]

Any object type $A$ can be lifted to the meta-level as $\lift A : \Ur$, and any
object term $t : A$ can be lifted as $\quot t : \lift A$, similarly to the
original presentation of 2LTT \cite{Kovacs2022-vb}. Splicing also works in the
same way; if $t : \lift A$, then $\splice t : A$. Universe levels will be
implicit in the rest of this presentation, as they are orthogonal to its main
content.

The universes $\Ur$ and $\Uv$ are closed under simple $\Sigma$ and $\Pi$ types,
and the universe $\Um$ is closed under dependent $\Sigma$ and $\Pi$ types.

The \emph{categories with families} interpretation of $\cat{G}$ is given by the
symbols $\Ty_{\cat{G},m}$, $\Con_{\cat{G}}$, $\Sub_{\cat{G}}$, and
$\Tm_{\cat{G},m}$, where $m$ ranges over the two stages $\mta{Meta}$ and
$\mta{Val}$.

\subsection{Inductive data types}

We allow inductive data types to be defined in the meta fragment of $\cat{G}$,
as inductive families. These exist as first-class citizens, and we follow the
syntactical approach of \cite{Kaposi2020-is} ...

The sort for meta inductive types is $\Ui$, which is a subuniverse of $\Um$.
This sort interprets signatures $(A : \Ty_s, \Con_s \, A)$.

We have constructors and eliminators for inductive types in the meta fragment.

...

\subsection{Choice of representations}

Representable meta types, or inhabitants of $\Ur$, are meta types which can be
staged into the object level, but are not necessarily just lifted object types.
Indeed, lifting an object type is one way to acquire a representable meta type.
However, the more interesting way to do so is to attach a representation to a
meta-level type. This is captured by the rule
\[
  \infrule[Repr-Intro]{\Gamma \vdash A : \Ui \quad \Gamma \vdash R : \defin{Repr}\,A}
  {\Gamma \vdash A_R : \Ur} \,.
\]
In other words, any inductive type $A$ paired with a representation $R$ is a
representable meta type. The type family $\Repr$ is defined as
\begin{align*}
   & \recordwhere[\,(A: \Ui)]{Repr}                                       \\
   & \quad \defin{R} : \Uv                                                \\
   & \quad    \defin{c} : A [\lift{\defin R}] \to \Gen \, \defin R \quad  \\
   & \quad    \defin{i} : \lift{\defin R} \to \Gen \, A [\lift{\defin R}]
\end{align*}
It defines a representation to be a triple of an object type $R_A$, a
\emph{collapsing} function $c_A$, and an \emph{inspecting} function $i_A$.

The notation $A[N]$ is shorthand for $\defin{Syntax}\,A\,N$, where the
\defin{Syntax} type family is defined by
\[
  \data{Syntax} \,(A : \Ui)\,(N : \Um) = \defin{known} \, (A\,(\defin{Syntax}\,A\,N)) \mid \defin{opaque} \, N \,.
\]
where $A(B)$ is the endofunctor associated with the inductive type $A$ applied
to the meta type $B$ (need rules for that too).

The collapsing function is used to convert a partial syntactical representation
of a term of the inductive type $\mu A$ into a value of a chosen representation
type $R_A$.

The return type of the collapsing function is over the monad $\Gen$. This is
the code generation monad, first described in [Kovacs unpublished], which is
defined as
\[
  \data{Gen} \, (A : \Um) = \defin{unGen} \, (\{ R : \Uv \} \to (A \to \lift R) \to \lift R)
\]

The inspecting function is used to convert a value of the chosen representation
type $R_A$ into a partial syntactical representation of a term of the inductive
type $A$.

The subuniverse $\Ur$ can be reflected into the metatheory as a structure over
the base category $(\Sub_{\catG}, \Con_{\catG})$. The set
$\Ty_{\catG,\mR}\,\Gamma$ is the set of representable types in representable
context $\Gamma$, defined as $\Tm_{\catG,\mM}\,\Gamma\,\Ur$. Similarly, the set
$\Tm_{\catG,\mR}\,\Gamma\,A$ is the set of terms of representable type $A$ in
context $\Gamma$, defined as $\Tm_{\catG,\mM}\,\Gamma$ restricted to
$\Ty_{\catG,\mR}\,\Gamma$.

\subsection{Translating $\catG_\mR$ to $\catG_\mV$}

The CWF defined by $\catG$ is contextual \cite{Castellan2019-sh}, which means
that the contexts are inductively defined as dependent lists of types
$\Ty_\cat{G}$. Therefore, we can define restrictions of the objects
$\Con_{\catG}$ and morphisms $\Sub_{\catG}$ to only contain representable
types, which we call $\Con_{\catG,\mR}$ and $\Sub_{\catG,\mR}$. This makes
\[
  (\Con_{\catG, \mR}, \Sub_{\catG, \mR}, \Ty_{\catG, \mR}, \Tm_{\catG, \mR})
\]
into a syntactical (initial) CWF which we call $\catG_\mR$ (Proof?). We can
perform a similar restriction on the object fragment to obtain
\[
  (\Con_{\catG, \mV}, \Sub_{\catG, \mV}, \Ty_{\catG, \mV}, \Tm_{\catG, \mV})
\]
which is also a syntactical CWF that we call $\catG_\mV$ (Proof?).

The translation of a representable meta-program into an object program is done
through a syntactical CWF morphism
\begin{align*}
  \fun{T} : \catG_\mR & \fto \catG_\mV
\end{align*}
We exploit the initiality of the CWF $\catG_\mR$ to define the translation
inductively over its syntax:

\begin{align*}
   & \fun T            : \Con_{\catG, \mR} \to \Con_{\catG, \mV} \\
   & \fun T(\cdot)     = \cdot                                   \\
   & \fun T(\Gamma, A) = \fun T(\Gamma), \fun T(A)
\end{align*}

\begin{align*}
   & \fun T            : \Sub_{\catG, \mR} \; \Gamma \; \Delta \to \Sub_{\catG, \mV}\; \fun T\Gamma \; \fun T\Delta \\
   & \fun T(\mta{id})  = \mta{id}                                                                                   \\
   & \fun T(\gamma, f) = \fun T \gamma , \fun T f
\end{align*}

\begin{align*}
   & \fun T            : \Ty_{\catG, \mR} \; \Gamma \to \Ty_{\catG, \mV}\; \fun T\Gamma \\
   & \fun T(A \to B)  = \fun T A \to \fun T B                                           \\
   & \fun T(A \times B) = \fun T A \times \fun T B                                      \\
   & \fun T(1) = 1                                                                      \\
   & \fun T(A_R) = R.\defin{R}
\end{align*}

\begin{align*}
   & \fun T            : \Tm_{\catG, \mR} \; \Gamma \; A \to \Tm_{\catG, \mV}\; \fun T\Gamma \; \fun T A                      \\
   & \fun T(\lambda x . a)  = \lambda x . \fun T a                                                                            \\
   & \fun T((a, b)) = (\fun T a, \fun T b)                                                                                    \\
   & \fun T(\star) = \star                                                                                                    \\
   & \fun T(c \,@\, a)_{A = A_R} = \splice{(\defin{runGen} \ (R.\defin{c} \ (\defin{known}\ (c \,@\, T'(a)))) \  \defin{id})}
\end{align*}

