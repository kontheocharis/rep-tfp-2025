\section{The transformation}\label{sec:prelim}

The technique for transforming inductive data types into custom data structures
will be phrased in the language of 2-level type theory (2LTT)
\cite{Kovacs2022-vb}.

\subsection{The 2-level type theory $\cat{G}$}

We will work in a 2LTT which we denote $\cat{G}$. The meta fragment of
$\cat{G}$ contains a universe hierarchy $\univ{\mta{Meta},i}$ of meta-level
types, and a single universe of values $\Uv$. Additionally, the universe
$\univ{\mta{Meta},0}$ has a subuniverse $\Ur$ of "representable" meta-level
types. We have
\[
  \univ{\mta{Meta},i} : \univ{\mta{Meta},i+1} \qquad \Ur : \univ{\mta{Meta},1} \qquad \Uv : \univ{\mta{Meta},0} \,.
\]

Any object type $A$ can be lifted to the meta-level as $\lift A : \Ur$, and any
object term $t : A$ can be lifted as $\quot t : \lift A$, similarly to the
original presentation of 2LTT \cite{Kovacs2022-vb}. Splicing also works in the
same way; if $t : \lift A$, then $\splice t : A$. Universe levels will be
implicit in the rest of this presentation, as they are orthogonal to its main
content.

The universes $\Ur$ and $\Uv$ are closed under simple $\Sigma$ and $\Pi$ types,
and the universe $\Um$ is closed under dependent $\Sigma$ and $\Pi$ types.

The \emph{categories with families} interpretation of $\cat{G}$ is given by the
symbols $\Ty_{\cat{G},m}$, $\Con_{\cat{G}}$, $\Sub_{\cat{G}}$, and
$\Tm_{\cat{G},m}$, where $m$ ranges over the two stages $\mta{Meta}$ and
$\mta{Obj}$.

Is it fine to have a sort for $\Ur$?

\subsection{Inductive data types}

We allow inductive data types to be defined in the meta fragment of $\cat{G}$,
as inductive families. These exist as first-class citizens, and we follow the
syntactical approach of \cite{Dybjer1994-zx} ...

The sort for meta inductive types is $\Ui$, which is a subuniverse of $\Um$.
This sort interprets signatures $(A : \Ty_s, \Con_s \, A)$.

We have constructors and eliminators for inductive types in the meta fragment.

...

\subsection{Choice of representations}

Representable meta types, or inhabitants of $\Ur$, are meta types which can be
staged into the object level, but are not necessarily just lifted object types.
Indeed, lifting an object type is one way to acquire a representable meta type.
However, the more interesting way to do so is to attach a representation to a
meta-level type. This is captured by the rule
\[
  \infrule[Repr-Intro]{\Gamma \vdash A : \Ui \quad \Gamma \vdash R : \defin{Repr}\,A}
  {\Gamma \vdash A_R : \Ur} \,.
\]
In other words, any inductive type $A$ paired with a representation $R$ is a
representable meta type. The type family $\Repr$ is defined as
\begin{align*}
   & \recordwhere[\,(A: \Ui)]{Repr}                                                   \\
   & \quad \defin{R} : \Uv                                                            \\
   & \quad    \defin{c} : \hat{A} [\lift{\defin R}] \to \Gen \, \lift{\defin R} \quad \\
   & \quad    \defin{i} : \lift{\defin R} \to \Gen \, \hat{A}(\lift{\defin R})
\end{align*}
It defines a representation to be a triple of an object type $R_A$, a
\emph{collapsing} function $c_A$, and an \emph{inspecting} function $i_A$.

The notation $M[N]$ is shorthand for $\defin{Syntax}\,M\,N$, where the
\defin{Syntax} type family is defined by
\[
  \data{Syntax} \,(M : \Um \to \Um)\,(N : \Um) = \defin{known} \, (M\,(\defin{Syntax}\,M\,N)) \mid \defin{opaque} \, N \,.
\]
where $A(B)$ is the endofunctor associated with the inductive type $A$ applied
to the meta type $B$ (need rules for that too).

The collapsing function is used to convert a partial syntactical representation
of a term of the inductive type $\mu A$ into a value of a chosen representation
type $R_A$.

The return type of the collapsing function is over the monad $\Gen$. This is
the code generation monad, first described in [Kovacs unpublished], which is
defined as
\[
  \data{Gen} \, (A : \Um) = \defin{unGen} \, (\{ R : \Uv \} \to (A \to \lift R) \to \lift R)
\]

The inspecting function is used to convert a value of the chosen representation
type $R_A$ into a partial syntactical representation of a term of the inductive
type $A$.

The subuniverse $\Ur$ can be reflected into the metatheory as a structure over
the base category $(\Sub_{\catG}, \Con_{\catG})$. The set
$\Ty_{\catG,\mR}\,\Gamma$ is the set of representable types in representable
context $\Gamma$, defined as $\Tm_{\catG,\mM}\,\Gamma\,\Ur$. Similarly, the set
$\Tm_{\catG,\mR}\,\Gamma\,A$ is the set of terms of representable type $A$ in
context $\Gamma$, defined as $\Tm_{\catG,\mM}\,\Gamma$ restricted to
$\Ty_{\catG,\mR}\,\Gamma$.

\subsection{Specialising functions}

\[
  \infrule[Spec-Intro]{\Gamma \vdash A_R : \Ur \quad \Gamma \vdash B_S : \Ur \quad \Gamma, x : A_R \vdash b : B_S \quad \Gamma \vdash r : \lift{R.\defin R} \to \lift{S.\defin R}}
  {\Gamma \vdash \lambda_r x . \, b : A_R \to B_R} \,.
\]

\subsection{Translating $\catG_\mR$ to $\catG_\mV$}

The CWF defined by $\catG$ is contextual \cite{Castellan2019-sh}, which means
that the contexts are inductively defined as dependent lists of types
$\Ty_\cat{G}$. Therefore, we can define restrictions of the objects
$\Con_{\catG}$ and morphisms $\Sub_{\catG}$ to only contain representable
inductive types, which we call $\Con_{\catG,\mR}$ and $\Sub_{\catG,\mR}$. This
makes
\[
  (\Con_{\catG, \mR}, \Sub_{\catG, \mR}, \Ty_{\catG, \mR}, \Tm_{\catG, \mR})
\]
into a syntactical (initial) CWF which we call $\catG_\mR$ (Proof?). We can
perform a similar restriction to no inductive types at all, to obtain
\[
  (\Con_{\catG, \mV}, \Sub_{\catG, \mV}, \Ty_{\catG, \mV}, \Tm_{\catG, \mV})
\]
which is also a syntactical CWF that we call $\catG_\mV$ (Proof?).

The translation of a representable meta-program into a valuated meta-program is
done through a syntactical CWF morphism
\begin{align*}
  \fun{T} : \catG_\mR & \fto \catG_\mV
\end{align*}
We exploit the initiality of the CWF $\catG_\mR$ to define the translation
inductively over its syntax:

\begin{align*}
   & \fun T            : \Con_{\catG, \mR} \to \Con_{\catG, \mV} \\
   & \fun T(\cdot)     = \cdot                                   \\
   & \fun T(\Gamma, A) = \fun T(\Gamma), \fun T(A)
\end{align*}

\begin{align*}
   & \fun T            : \Sub_{\catG, \mR} \; \Gamma \; \Delta \to \Sub_{\catG, \mV}\; \fun T\Gamma \; \fun T\Delta \\
   & \fun T(\mta{id})  = \mta{id}                                                                                   \\
   & \fun T(\gamma, f) = \fun T \gamma , \fun T f
\end{align*}

\begin{align*}
   & \fun T            : \Ty_{\catG, \mR} \; {\Gamma} \to \Ty_{\catG, \mV}\; \fun T \Gamma \\
   & \fun T(\Pi x : A .\, B)  = \Pi x : \fun T A . \fun T B                                \\
   & \fun T(\lift V) = \lift V                                                             \\
   & \fun T(A_R) = \lift R.\defin{R}
\end{align*}

\begin{align*}
   & \fun T            : \Tm_{\catG, \mR} \; {\Gamma} \; A \to \Tm_{\catG, \mV}\; {\fun T \Gamma} \; \fun T A                                                      \\
   & \fun T(\lambda x . a)  = \lambda x . \fun T a                                                                                                                 \\
   & \fun T(\lambda_r x . a)  = r                                                                                                                                  \\
   & \fun T(a \, b)  = (\fun T a) \, (\fun T b)                                                                                                                    \\
   & \fun T(x) = x                                                                                                                                                 \\
   & \fun T(\quot {p}) = \quot {p}                                                                                                                                 \\
   & \fun T(c_{A_R} \, \hat{@} \, \vv{a} \,@\, \vv{r}) =  \defin{runGen} \ (R.\defin{c} \ (c_{A_R} \, \hat{@} \, \fun S \vv{a} \,@\, \fun S \vv{r})) \  \defin{id} \\
   & \fun T(\inte{case}_{A_R}\ m\ \vv{a}) =  \defin{runGen} \ (R.\defin{i} \ \fun T m) \  (\lambda x.\, \inte{case}\ x \ \fun T\vv{a})                             \\
\end{align*}

\begin{align*}
   & \fun S            : \Tm_{\catG, \mR} \; {\Gamma} \; A_R \to \Tm_{\catG,\mR}\; {\fun T \Gamma} \; A[\lift{R.\defin{R}}] \\
   & \fun S(c \, \hat{@} \, \vv{a} \,@\, \vv{r}) = \defin{known}\ (c \, \hat{@} \, \fun S\vv{a} \,@\, \fun S\vv{r})         \\
   & \fun S(a)  = \defin{opaque}\ (\fun T a)
\end{align*}

Issues with the above:

\begin{itemize}
  \item Unclear what happens to the constructor data. \cite{Kaposi2020-is} leaves
        non-recursive parameters as metatheoretic sets, which is not good enough! We
        want these to be actual types in the language!
\end{itemize}

Coalgebra should be phrased in terms of views for semantic correctness
\cite{Allais2023-pf,Allais2023-zq} ?
