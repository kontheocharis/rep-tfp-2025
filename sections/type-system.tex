\section{A type system for data representations}\label{sec:type-system}

This section provides an overview of the language $\lambdarep$, which has
dependent types and representations for inductive families and global function
definitions. We start with a core language with inductive families $\lambdaind$,
that is extended with data representations to form $\lambdarep$. All of the
examples in the paper are written in a surface language that elaborates to
$\lambdarep$.

The core languge $\lambdaind$, is a dependent type theory with $\Pi$ and a
Coquand-style universe hierarchy $\univ_i$ \cite[2.1]{Gratzer2020-kf}, extended
with strictly positive inductive families and global definitions similarly to
\cite{Goguen2006-sy}. We follow a similar approach to \cite{Cockx2018-fk} by
packaging named inductive constructions and global function definitions into a
signature $\Sigma$, and indexing contexts by signatures.

\newcommand{\ValidCase}{\mta{ValidCase}}

\subsection{Extending $\lambdaind$ with representations}\label{sub:lambdarep}

We extend the language $\lambdaind$ to form $\lambdarep$, which allows users to
define custom representations for inductive types and global functions. First,
we add a type former
\begin{equation}\label{eq:repr-ty}
  \Repr{} : \Ty\ (\Sigma\mid \Gamma) \to \Ty\ (\Sigma\mid \Gamma)
\end{equation}
along with two new terms in the syntax, forming an isomorphism
\begin{equation}\label{eq:repr-iso}
  \repr{} : \Tm\ (\Sigma\mid \Gamma)\ T \simeq \Tm\ (\Sigma\mid \Gamma)\ (\Repr T) : \unrepr{} \,.
\end{equation}
which holds definitionally and preserves $\Pi$ and universes. The type $\Repr T$
is the defined representation of the type $T$. The term $\repr{}$ takes a term
of type $T$ to its representation of type $\Repr T$, and $\unrepr{}$ undoes the
effect of $\repr{}$, treating a represented term as an inhabitant of its
original type. These new constructs satisfy certain equalities, some of which
are given in \cref{fig:global-rep-eq}. New valid signature items are introduced,
corresponding to representation definitions for components of inductive families
and global function definitions.

\begin{figure}[h]
  \begin{mathpar}
  \inferrule[Repr-Ctor-Id]
  {
    \Sreprvar{\ctorlab c\ \Pi}{\kappa} \in \Sigma
  }
  {\Sigma \mid \Gamma \vdash \repr{(\ctorlab{c}\ \delta\ \pi)} \equiv \kappa [\delta, \pi] : A[\delta, \xi[\pi]]} \and
  \inferrule[Repr-Data-Id]
  {
    \Sreprvar{\datalab D\ \Delta\ \Xi}{A} \in \Sigma
  }
  {\Sigma \mid \Gamma \vdash \istype{\Repr{(\datalab{D}\ \delta\ \psi)} \equiv A [\delta,\psi]}}
  \end{mathpar}
  \caption{Definitional equalities for $\Repr{}$ and $\repr{}$ relating to data
  types and constructors with defined representations. Similar equalities hold
  for representations of global function definitions and eliminators, albeit
  propositionally.}
  \label{fig:global-rep-eq}
\end{figure}

We state some basic lemmas below. The proof are left to the full version
of the paper, along with the formalisation of computational irrelevance.

\begin{lemma}
  The term formers $\repr{}$ and $\unrepr{}$ are injective, i.e.
  \begin{mathpar}
    \inferrule
    {
      \Sigma \mid \Gamma \vdash \repr{t} \equiv \repr{t'} : \Repr T
    }
    {
      \Sigma \mid \Gamma \vdash t \equiv t' : T
    } \and
    \inferrule
    {
      \Sigma \mid \Gamma \vdash \unrepr{t} \equiv \unrepr{t'} : T
    }
    {
      \Sigma \mid \Gamma \vdash t \equiv t' : \Repr T
    }
  \end{mathpar}
\end{lemma}

\begin{lemma}
  The type former $\Repr{}$ is injective up to internal isomorphism, i.e.
  \begin{mathpar}
    \inferrule
    {
      \Sigma \mid \Gamma \vdash \istype{\Repr T \equiv \Repr T'}
    }
    {
      \Sigma \mid \Gamma \vdash p : T\ \datalab{$\simeq$}\ T'
    }
  \end{mathpar}
  Moreover, this isomorphism is computationally irrelevant.
\end{lemma}

\section{Translating from $\lambdarep$ to $\lambdaind$}

We can define a translation step $\R$ from $\lambdarep$ to
$\lambdaind^{\textsc{Ext}}$, meant to be applied during the compilation process.
More specifically, the translation target is the extensional flavour of
$\lambdaind$ by adding the equality reflection rule. We do this by translating
well-formed contexts, substitutions, types, and terms in a mutual manner such
that definitional equality is preserved. $\R$ preserves the structure of
$\lambdarep$, but maps constructs to their terminal representations. Eliminator
coherence rules are preserved by reflecting the propositional coherence rules
provided by the defined representations. We will prove some desired properties
of $\R$ \cite{Boulier2017-cm} such as typing and computational soundness, and
preservation of consistency. The final program can then be converted into a
simply-typed language which erases irrelevant data. We can recover a program in
$\lambdaind$ by translating extensional typing derivations to intensional proofs
\cite{Winterhalter2019-zw}.
