\section{A type system for data representations}\label{sec:type-system}

This section provides an overview of the language $\lambdarep$, which has
dependent types and representations for inductive families and global function
definitions. We start with a core language with inductive families $\lambdaind$,
that is extended with data representations to form $\lambdarep$. All of the
examples in the paper are written in a surface language that elaborates to
$\lambdarep$.

We work in an extensional metatheory with universes $\Set_i$ (though levels are
ommited for simplicity), $(a : A) \times B$ for dependent pairs, $(a : A) \to B$
for dependent products, and $=$ for equality. The metatheory also supports
quotient-inductive-inductive definitions, which are used to define the syntaxes
of the languages presented in this paper in the style of Kaposi and
Altenkirch~[CITE]. Weakening of terms is generally also left implicit to reduce
syntactic noise, and sometimes higher-order abstract syntax notation is used for the
languages defined.





% & \mta{ctor} &&: (i : \mta{ind}\ (P, P, T) \in \Gamma) \to (p : \Tms\ \Gamma\ P) \\
% &            && \to (a : \mta{In}\ T\ (\mta{data}\ i\ p)\ p) \to \Tm\ \Gamma\ (\mta{data}\ i\ p\ xi) \\[0.5em]
% & \mta{elim} &&: (i : \mta{ind}\ (P, P, T) \in \Gamma) \to (p : \Tms\ \Gamma\ P) \\
% &            && \to (M : \mta{Motive}\ T\ (\mta{data}\ i\ p)) \to (m : \mta{Methods}\ M) \to \mta{Section}\ M \\
% & \mta{match} &&: (\mta{elim}\ i\ p\ M\ m)[\langle p, \mta{ctor}\ i\ p\ n\ a \rangle] = (m\,!\,n)[\langle a , \mta{elim}\ i\ p\ M\ m \fmap a \rangle]
% \end{alignat*}


\newcommand{\ValidCase}{\mta{ValidCase}}

\subsection{Representations of data types as inductive algebras}

A representation of a data type must be able to emulate the behaviour of the
original data type. In turn, the behaviour of the original data type is
determined by its elimination, or induction principle. This means that a
representation $r$ of a data type $\mta{data}\ P\ T$ should provide an
implementation of induction. Induction can be characterised in terms of algebras
and displayed algebras of theories.

An algebra $(X, a) : \mta{Alg}\ T$ for a carrier set $X$ and theory (context)
$T$ defines a way to interpret the structure of $T$ in terms of a type in a type theory
$X : \mta{Ty}\ \Gamma$. This is done by providing some data that matches $T$. The
function arrows in $T$ are interpreted as functions in the type theory, and
and $\iota$ as $X$. For example, natural numbers defined by
\[
	\mta{NatTh} = \bullet \rhd zero : \iota \rhd succ:\iota \Rightarrow \iota
\]
have algebras
\[
	\mta{Alg}\ \mta{NatTh}\simeq (X : \Ty\ \Gamma) \times (zero : \Tm\ \Gamma\ X) \times (succ : \Tm\ \Gamma\ (\Pi\ X\ X))
\]
An algebra $(R, r)$ supports recursion if for all other algebras $(X, a)$ there
is a function from $R$ to $X$ which preserves the structure of $T$. The recursor
is typed as
\[
	\mta{Rec}_R := ((X, a) : \mta{Alg}\ T) \to (p : \Tms\ \Gamma\ P) \to \Tm\ \Gamma\ R[\Msub p] \to \Tm\ \Gamma\ X[\Msub p]
\]
In the case of natural numbers, this computes to
\begin{align*}
	\mta{Rec}_{\mta{NatTh}} \simeq\  & (X : \Ty\ \Gamma)                             \\
	                                 & \to (zero : \Tm\ \Gamma\ X)                   \\
	                                 & \to (succ : \Tm\ \Gamma\ (\Pi\ X\ X))         \\
	                                 & \to \Tm\ \Gamma\ \mta{Nat} \to \Tm\ \Gamma\ X
\end{align*}
if $\mta{Nat} : \mta{Ty}\ \Gamma$ is the carrier set of the term algebra of
natural numbers in the type theory, in some sense defining the `actual' natural
numbers. This algebra supports recursion. The output $\mta{rec}\ (X, a)\ p\ n :
	\Tm\ \Gamma\ X$ must pick its values from the algebra
$a$. For natural numbers, this results in the equations
\begin{align*}
	\mta{rec}\ (X, zero, succ)\ \mta{zero}                  & = zero                                             \\
	\mta{rec}\ (X, zero, succ))\ (\mta{app}\ \mta{succ}\ n) & = \mta{app}\ succ\ (\mta{rec}\ (X, zero, succ)\ n)
\end{align*}
for an algebra $(X, zero, succ)$ where $\mta{zero}$ and $\mta{succ}$ are from
the term algebra.

For induction, we need the elimination type to depend not only on the parameters $p$
but also on the data type itself.
\begin{definition}
	An algebra $(X, a) : \mta{Alg}\ T$ is \emph{inductive} if for every
	\emph{displayed} algebra $(D, d) : \mta{DispAlg}\ (X, a)$ there is a
	\emph{section} $s : \mta{Section}\ (D, d)$.
\end{definition}
The displayed algebras for natural numbers are
\begin{align*}
	\mta{DispAlg}\ (X, zero, succ) & \simeq (Y : \Ty\ (\Gamma \rhd X))                                                      \\
	                               & \quad \times (zero' : \Tm\ \Gamma\ Y[zero])                                            \\
	                               & \quad \times (succ' : \Tm\ \Gamma\ (\Pi\ (x : X)\ (\Pi\ Y[x]\ Y[\mta{app}\ succ\ x])))
\end{align*}
and sections are the dependent functions
\begin{align*}
	\mta{Section}\  & \{(X, zero, succ)\}\ (Y, zero', succ')                                                                                           \\
	                & \simeq (f : \Tm\ \Gamma\ (\Pi\ (x : X)\ Y[x]))                                                                                   \\
	                & \quad \times (\mta{app}\ f\ zero = zero')                                                                                        \\
	                & \quad \times ((x : \Tm\ \Gamma\ X) \to \mta{app}\ f\ (\mta{app}\ succ\ x) = \mta{app}\ (\mta{app}\ succ'\ x)\ (\mta{app}\ f\ x))
\end{align*}
A displayed algebra packages the motive and methods of an induction principle, while the
section takes the subject of the induction and produces the motive.
The equations that are required for a section have been stated to hold on the level of the
equality of the metatheory, but soon we will utilise a notion of section where the equalities
only hold up to the internal equality type of $\lambdaind$.

\subsection{The core language, $\lambdaind$}

The languge $\lambdaind$, is a dependent type theory with $\Pi$, $\mta{Id}$, and
a universe $\univ$.
It also has inductive families and global definitions. We follow a similar
approach to Cockx~and~Abel~\cite{Cockx2018-fk} by packaging named inductive
constructions and function definitions into a signature $\Sigma : \Sig$, and
indexing contexts by signatures. The contexts $\Con$ in the resulting theory are
pairs $(\Sigma : \Sig) \times \Loc\ \Sigma$ where $\Loc\ \Sigma$ are local
contexts given by a closed telescope of types as usual. Items in a signature
$\Sigma$ can be either

\begin{itemize}
	\item function definitions $\mta{def}\ P\ A\ t$ for some parameters $P : \Loc\
		      \Sigma$, return type $A : \Ty\ (\Sigma, P)$ and implementation $t : \Tm\ A\ (\Sigma, P)$,
	\item postulates $\mta{post}\ P\ A$ for some parameters $P : \Loc\
		      \Sigma$ and return type $A : \Ty\ (\Sigma, P)$, or
	\item inductive type definitions $\mta{data}\ P\ T$ for some indices $P :
		      \Loc\ \Sigma$ and theory $T : \Theory\ (\Sigma, \bullet)\ P$.
\end{itemize}

The $\Theory\ \Gamma\ P$ sort stands for the contexts $\Con_{\mathbb{A}\ \Gamma\
		P}$ of a theory of positive signatures \cite{Kovacs2023-gq} $\mathbb{A}$ indexed
by contexts $\Gamma$ and telescopes $P$ in $\lambdaind$. In particular,
$\mathbb{A}\ \Gamma\ P$ describes positive signatures for a single family of
sorts $\iota : \Tms\ \Gamma\ P \to \Ty_{\mathbb{A}\ \Gamma\ P}$. An inductive
family can be defined as a context in this theory like $\bullet \rhd zero :
	\iota \rhd succ:\iota \Rightarrow \iota$. This context is allowed to reference
types in $\lambdaind$ from context $\Gamma$ and must apply $\iota$ to a spine of
parameters $P$. The $\mta{data}$ definition packages the parameters $P$ and the
context for the inductive family being defined. For vectors this would be
\begin{align*}
	 & \mta{Vect} : \mta{data}                                                                                                        \\
	 & \quad\begin{aligned}
		        \quad (\bullet & \rhd\univ \rhd \mta{Nat})\                                                                               \\
		        \quad (\bullet & \rhd nil : (T : \univ) \to \iota\ T\ \mta{zero}                                                          \\
		        \quad          & \rhd cons : (T : \univ) \to (n : \mta{Nat}) \to \iota\ T\ n \Rightarrow T \to \iota\ T\ (\mta{succ}\ n))
	        \end{aligned}
\end{align*}
The function arrows $\to$ and $\Rightarrow$ are different because the former
denotes abstraction over an external type (from $\Ty\ \Gamma$) and the latter a
recursive occurence of the inductive type being defined (with indices from
$\Tms\ \Gamma\ P$). All function arrows must eventually return $\iota\ p$ for
some $p : \Tms\ \Gamma\ P$

In order to actually construct inductive types in $\lambdaind$, we need to
extend the syntax with some term and type formers. First, we add a type former
\[
	\mta{D} : \mta{data}\ P\ T \in \Sigma \to \Ty\ (\Sigma, \Delta \rhd P)
\]
which, given a data definition $i$ in $\Sigma$, and terms for its
indices $p$, constructs the data type $(\mta{D}\ i)[p]$. The relation $I \in
	\Sigma$ should be thought of as `variables for item $I$ in a signature
$\Sigma$', in a similar way to how $\mta{Var}\ \Gamma\ A$ defines variables for
type $A$ in a local context $\Gamma$.

Additionally, we add a constructor term
\[
	\mta{C} :\ \forall i.\ (a : \mta{Args}\ T\ (\mta{D}\ i)) \to \Tm\ \Gamma\ (\mta{D}\ i)[\Msub{\mta{out}\ a}] \\
\]
which fully applied, defines the data constructor $\mta{C}\ a$ of type
$\mta{D}\ i\ p$ for arguments $a$. The type $\mta{Args}\ T\ X$ is defined such
that
\begin{equation}
	\mta{isAlgebra} : ((a : \mta{Args}\ T\ X) \to \Tm\ \Gamma\ X[\Msub{\mta{out}\ a}]) \simeq \mta{Algebra}\ T\ X \,.\label{eq:args-iso}
\end{equation}
This is possible because the algebras for a theory $T$ over $\mta{D}\ i\ p$ are
described by a metatheoretic product of internal curried functions ending in
$\mta{D}\ i$, which is equivalent to a function out of a coproduct
$\mta{Args}\ i$ into $\mta{D}\ i$. All occurences of $\mta{Tm}$ in
$\mta{Args}$ occur positively and are part of the inductive syntax.

\begin{definition}
	The \emph{internal term algebra} $\mta{TmAlg}\ \Gamma\ i$ of a data type $i$ is
	the algebra with carrier $\mta{D}\ i$, given by $\mta{isAlgebra}\ \mta{C}_i$.
\end{definition}

Finally, we add an eliminator term
\[
	\mta{E} :\ \forall i.\ (M : \Ty\ (\Gamma \rhd P \rhd \mta{D}\ i)) \to \mta{Methods}\ T\ M \to \Tm\ (\Gamma \rhd P \rhd \mta{D}\ i)\ M \\
\]
which given a data definition $i$ in $\Sigma$, a motive and methods for $i$,
eliminates each $d : (\mta{D}\ i)[\Msub p]$ into $M[\Msub{p;d}]$. This captures the induction
principle of the data type. The motive and methods package a displayed algebra,
and the output of $\mta{E}$ captures the data part of the produced section. The
structure preservation part of the section is captured by an equality
constructor
\[
	\mta{E-id}\ M\ m : \forall a.\ \mta{E}\ M\ m\ [\Msub{\mta{out}\ a; \mta{C}\ a}] = \mta{applyDisp}\ m\ a\ (\mta{E}\ M\ m)
\]
The type $\mta{Methods}$ describes displayed algebras of the internal term algebra.
It has an accompanying function $\mta{applyDisp}$ with the form
\begin{align*}
    \mta{applyDisp} :\ &(m : \mta{Methods}\ M) \to (a : \mta{Args}\ i) \\
    &\to (s : \Tm\ (\Gamma \rhd P \rhd \mta{D}\ i)\ M) \to \Tm\ \Gamma\ (M[\Msub{\mta{out}\ a; \mta{C}\ a}]
\end{align*}
which applies the arguments $a$ to the appropriate method in $m$, sampling the inductive hypothesis
from the section $s$.
The output of the eliminator paired with the $\mta{E-id}$ equality
constructor defines a section of this displayed algebra
\begin{align*}
    \mta{isSection}\ M\ m :\ & (f : \Tm\ (\Gamma \rhd P \rhd \mta{D}\ i)\ M) \\
    &\quad\times (\forall a.\ f\ [\Msub{\mta{out}\ a;\mta{C}\ a}] = \mta{applyDisp}\ m\ a\ f) \\
    &\simeq \mta{Section}\ (M,\ m)
\end{align*}

\begin{lemma}
	The internal term algebra of a data type $i$ is inductive.
	\begin{proof}
		Every displayed algebra $(M, m)$, provides a motive $M$ and methods $m$. Then we get a section by $\mta{isSection}\ (\mta{E}\ M\ m, \mta{E-id}\ M\ m)$.
	\end{proof}
\end{lemma}

% \begin{definition}
% A \emph{representation} of a theory $T$ is an algebra $(R, r)$ of the theory $T$ which supports induction.
% \end{definition}

\subsection{Extending $\lambdaind$ with representations}

We extend the language $\lambdaind$ to form $\lambdarep$, which allows users to
define custom representations for inductive types and global functions.

\begin{definition}
	A representation of an inductive type $\mta{data}\ P\ T$ is an inductive algebra for $T$.
\end{definition}

We modify the syntax for signatures $\Sig$ to introduce representations:
\begin{align*}
	 & \bullet : \Sig \\
	 & \rhd : (\Sigma : \Sig) \to \Item\ \Sigma \to \Sig \\
	 & \unrhd : (\Sigma : \Sig) \to (I : \Item\ \Sigma) \to \Rep\ \Sigma\ I \to \Sig \,.
\end{align*}
Representations in turn are defined as
\begin{align*}
& \Rep : (\Sigma : \Sig) \to \Item\ \Sigma \to \Set \\
& \mta{data-rep} : (a : \mta{Alg}\ T) \to \mta{Inductive}\ a \to \Rep\ \Sigma\ (\mta{data}\ P\ T) \\
& \mta{def-rep} : (x : \Tm\ (\Sigma, P)\ A) \to \Tm\ (\Sigma, P)\ (\mta{Id}\ x\ t) \to \Rep\ \Sigma\ (\mta{def}\ P\ A\ t)
\end{align*}
We also include representations for definitions, where a definition can be
represented by a term propositionally equal to original definition, but perhaps
with better computational properties.
We can define a decidable relation $R \in_i \Sigma'$ to mean that $R :
\mta{Rep}\ \Sigma\ I$ is the representation of an item $I : \mta{Item}\ \Sigma$
where $i : I \in \Sigma'$.
This relation is a proposition, so it is proof-irrelevant. Furthermore, it is stable under
weakening of contexts and signatures, because each item can only be represented once in a signature.

To allow reasoning about representations in $\lambdarep$ we add a type former
\begin{equation}\label{eq:repr-ty}
	\MRepr{} : \Ty\ \Gamma \to \Ty\ \Gamma
\end{equation}
along with two new terms in the syntax, forming an isomorphism
\begin{equation}\label{eq:repr-iso}
	\Mrepr{} : \Tm\ \Gamma\ T \simeq \Tm\ \Gamma\ (\MRepr\ T) : \Munrepr{} \,.
\end{equation}
which holds definitionally and preserves $\Pi$, $\mta{Id}$ and universes. The
type $\MRepr\ T$ is the defined representation of the type $T$. The term
$\Mrepr{}$ takes a term of type $T$ to its representation of type $\MRepr\ T$,
and $\Munrepr{}$ undoes the
effect of $\Mrepr{}$, treating a represented term as an inhabitant of its
original type. These new constructs come with equality constructors in the syntax
shown in \cref{fig:lambdaind-repr-coherence-pi-univ}.

\begin{figure}[H]
  \begin{minipage}[t]{0.5\textwidth}%
  \begin{alignat*}{2}
  & \mta{reprr} &&: \Munrepr\ (\Mrepr\ t) \equiv t \\
  & \mta{reprl} &&: \Mrepr\ (\Munrepr\ t) \equiv t \\[1em]
  & \MRepr\text{-}\Pi &&: \MRepr\ {(\Pi\ T\ U)} \equiv \Pi\ T\ (\MRepr\ U) \\
  & \Mrepr\text{-}\lambda &&: \Mrepr\ {(\lambda\ u)} \equiv \lambda\ (\Mrepr\ u) \\
  & \Munrepr\text{-}\lambda &&: \Munrepr\ {(\lambda\ u)} \equiv \lambda\ (\Munrepr\ u) \\
  & \Mrepr\text{-}@ &&: \Mrepr\ (\ap f) \equiv \ap {(\Mrepr\ f)} \\
  & \Munrepr\text{-}@ &&: \Munrepr\ (\ap f) \equiv \ap {(\Munrepr\ f)}
  \end{alignat*}
  \end{minipage}%
  \begin{minipage}[t]{0.5\textwidth}%
  \begin{alignat*}{2}
  & \MRepr\text{-}\univ &&: \MRepr\ {\univ} \equiv \univ \\
  & \Mrepr\text{-}\Code{} &&: \Mrepr\ {(\Code T)} \equiv \Code T \\
  & \Munrepr\text{-}\Code{} &&: \Munrepr\ {(\Code T)} \equiv \Code T \\[1em]
  & \MRepr[] &&: \MRepr\ {(T[\sigma])} \equiv (\MRepr\ {T})[\sigma] \\
  & \Mrepr[] &&: \Mrepr\ {(t[\sigma])} \equiv (\Mrepr\ {t})[\sigma] \\
  & \Munrepr[] &&: \Munrepr\ {(t[\sigma])} \equiv (\Munrepr\ {t})[\sigma]
  \end{alignat*}
  \end{minipage}%
  \caption{Coherence of the representation operators with substitutions, $\Pi$-types and
  universes. The terms $\MRepr\ (\El{t})$, $\Mrepr\ (\pi_2 \sigma)$ and
  $\Munrepr\ (\pi_2 \sigma)$ do not reduce.}
  \label{fig:lambdaind-repr-coherence-pi-univ}
\end{figure}

So far the representation operators do not really do anything. In order to make
them useful, we need to define how they compute when they encounter data types
which are represented in the signature.
In the following rules, $r : \mta{data-rep}\ (R, r)\ Q \in_i \Sigma$.
Firstly, we define the reduction that occurs when a type $\mta{D}\ i$ is represented,
\begin{equation}
  \mta{Repr-D} : \forall r.\ \MRepr\ (\mta{D}\ i) = R \,, \label{eq:lambdaind-Repr-D}
\end{equation}
yielding the carrier $R$ of the inductive algebra that represents it.
Additionally, we can add a similar rule for constructors, albeit in propositional form, where
\begin{align*}
&\mta{repr-C} : \forall r.\ \Tm\ (\Sigma, \Delta)\ (\mta{Id}\ (\Mrepr\ (\mta{C}\ a))\ (\mta{isAlgebra}^{-1}\ r\ (\mta{repr} \fmap a)))
\end{align*}
Here, the `fmap' operator $\fmap$ is used to apply the term former $\mta{repr}$
to the recursive part of the arguments of $a$. This is definable because
$\mta{Args}\ T\ X$ is natural in $X$ as it is a sum of products.

One might be tempted to make this equality definitional too. Unfortunately, this
would render conversion checking undecidable, because if one applies
$\mta{unrepr}$ to a term $\Mrepr\ (\mta{C}\ a)$ which has already been reduced
to its representation, $\mta{unrepr}\ (\mta{isAlgebra}^{-1}\ r\ (\mta{repr}
\fmap a)))$, there is no clear way to decide that this is convertible to
$\mta{C}\ a$ even though the definitional equality rules imply that it is (due
to the annihilation of $\mta{repr}$ and $\mta{unrepr}$). There is no
equivalent of $\mta{unrepr}$ for types, so \eqref{eq:lambdaind-Repr-D} preserves
the decidability of conversion checking.


We can also add a propositional equality rules for representing eliminators.
First, representing an eliminator just applies $\mta{repr}$ to the motive and methods:
\begin{align*}
&\mta{repr-E} : \forall r.\ \Tm\ (\Sigma, \Delta)\ (\mta{Id}\ (\Mrepr\ (\mta{E}\ M\ m))\ (\mta{E}\ (\mta{Repr}\ M)\ (\mta{repr} \fmap m)))
\end{align*}
Additionally, eliminating something using $\mta{E}$ should be the same as
eliminating the representation of that thing using the represented eliminator $Q$:
\begin{align*}
&\mta{unrepr-E} : \forall r.\ \Tm\ (\Sigma, \Delta)\ (\mta{Id}\ (\mta{E}\ M\ m)\ (\mta{Q}[\Msub{M^{\mta{Unrepr}}, m^{\mta{Unrepr}}}]))
\end{align*}
Here, the \mta{Unrepr} operations are typed as
\begin{align*}
&\_^{\mta{Unrepr}} : \Ty\ (\Gamma \rhd P \rhd \mta{D}\ i) \to \Ty\ (\Gamma \rhd P \rhd R) \\
&\_^{\mta{Unrepr}} : \mta{Methods}\ M \to \mta{Methods}\ M^{\mta{Unrepr}}\,.
\end{align*}
The first one takes a motive over $\mta{D}\ i$ and produces a motive over $R$ by applying
\mta{unrepr} to the $\mta{D}\ i$ in the context, while the second one takes some
methods over $\mta{D}\ i$ and produces methods over $R$ by applying
$\mta{unrepr}$ to all recursive arguments in the context, and then applying
$\mta{repr}$ to the result to obtain an inhabitant of $M^{\mta{Unrepr}}$.

Now we state some basic lemmas of the representation operators.

\begin{lemma}
	The term formers $\Mrepr{}$ and $\Munrepr{}$ are injective, i.e.
	$\Mrepr\ x = \Mrepr\ y \to x = y$ and $\Munrepr\ x = \Munrepr\ y \to x = y$.
	\begin{proof}
				By applying $\mta{unrepr}/\mta{repr}$ to both sides
				followed by the rule $\mta{reprr}/\mta{reprl}$.
	\end{proof}
\end{lemma}

\section{Translating from $\lambdarep$ to $\lambdaind$}

We can define a translation step $\R$ from $\lambdarep$ to
$\lambdaind^{\textsc{Ext}}$, meant to be applied during the compilation process.
More specifically, the translation target is the extensional flavour of
$\lambdaind$ by adding the equality reflection rule. We do this by translating
well-formed contexts, substitutions, types, and terms in a mutual manner such
that definitional equality is preserved. $\R$ preserves the structure of
$\lambdarep$, but maps constructs to their terminal representations.

Eliminator
coherence rules are preserved by reflecting the propositional coherence rules
provided by the defined representations. We will prove some desired properties
of $\R$ \cite{Boulier2017-cm} such as typing and computational soundness, and
preservation of consistency. The final program can then be converted into a
simply-typed language which erases irrelevant data. We can recover a program in
$\lambdaind$ by translating extensional typing derivations to intensional proofs
\cite{Winterhalter2019-zw}.
\cite{Winterhalter2019-zw}.

\begin{definition}
    A non-dependent function $f : \mta{Tm}\ \Gamma\ (\Pi\ A\ B)$ is \emph{computationally irrelevant} if
    $\R A = \R B$ and $\R f = \mta{id}_{\R A}$.
\end{definition}

\begin{lemma}
	The type former $\MRepr{}$ is injective up to internal isomorphism, i.e.
	\begin{equation}
	\mta{Repr}\ T = \mta{Repr}\ T' \to \Tm\ \Gamma\ (\mta{Iso}\ T\ T')
	\end{equation}
	Moreover, this isomorphism is computationally irrelevant.
	\begin{proof}
	The forward direction is given by first applying $\mta{repr}$ to $t$,
	transporting over the equality and then applying $\mta{unrepr}$. The
	backward direction is given by applying $\mta{repr}$ to $t'$, transporting
	over the equality and then applying $\mta{unrepr}$. The coherence holds by
	the rules $\mta{reprr}$ and $\mta{reprl}$. After applying $\R$, all
	representation operators are erased and the isomorphism is the identity on both
	sides.
	\end{proof}
\end{lemma}
