\section{A type system for data representations}\label{sec:type-system}


In this section, we will develop an extension of dependent type theory with
inductive families and custom data representations. We start in
\cref{sub:algebras} by exploring the semantics of data representations in terms
of algebras for signatures. In \cref{sub:lambdaind}
we define a core language with inductive families $\lambdaind$. In
\cref{sub:lambdarep}, we extend this language with data representations to form
$\lambdarep$. All of the examples in the paper are written in a surface language
that elaborates to $\lambdarep$.

We work in an extensional metatheory with a small universe $\Set$, $(a : A)
\times B$ for dependent pairs, $(a : A) \to B$ for dependent products, and $=$
for equality. The metatheory also supports quotient-inductive-inductive
definitions, which are used to define the syntaxes of the languages presented in
this paper in the style of Kaposi and Altenkirch~\cite{Altenkirch2016-zc}.
Weakening of terms is generally also left implicit to reduce syntactic noise,
and sometimes higher-order abstract syntax notation is used for the
languages defined.

\newcommand{\ValidCase}{\mta{ValidCase}}

\subsection{Algebras, displayed algebras and inductive algebras} \label{sub:algebras}

A representation of a data type must be able to emulate the behaviour of the
original data type. In turn, the behaviour of the original data type is
determined by its elimination, or induction principle. This means that a
representation of a data type should provide an implementation of induction of
the same `shape' as the original. Induction can be characterised in terms of
algebras and displayed algebras of algebraic signatures.

Algebraic signatures consist of a list of operations, each with a specified
arity. There are many flavours of algebraic signatures with varying degrees of
expressiveness. For this paper, we are interested in algebraic signatures which can
be used as a syntax for defining inductive families in a type theory. Thus, we define
\begin{align*}
    &\mta{Theory} : (\Gamma : \Con) \to \mta{Tel}\ \Gamma \to \Set \\
    &\bullet : \mta{Theory}\ \Gamma\ P \\
    &\rhd : (T : \mta{Theory}\ P) \to \mta{Op}\ P \to \mta{Theory}\ P \\[1em]
    &\mta{Op} : (\Gamma : \Con) \to \mta{Tel}\ \Gamma \to \Set \\
    &\Pi : (A : \Ty\ \Gamma) \to \mta{Op}\ (\Gamma \rhd A)\ P \to \mta{Op}\ \Gamma\ P \\
    &\Pi\iota : (p : \Tms\ \Gamma\ P) \to \mta{Op}\ \Gamma\ P \to \mta{Op}\ \Gamma\ P \\
    &\iota : (p : \Tms\ \Gamma\ P) \to \mta{Op}\ \Gamma\ P
\end{align*}
The $\mta{Theory}$ sort represents a simple class of algebraic signatures. We do
not call it $\mta{Signature}$ to avoid a name clash with another kind of `signatures'
that we will define later. Indeed, algebraic theories are a generalization of
algebraic signatures. Each theory has an associated telescope of parameters $P$
picked from some external type theory (not the metatheory), and contains a list of operations:
\begin{itemize}
    \item $\Pi\ A\ B$, a (dependent) abstraction over some type $A$ from the
    external type theory, of another operation $B$. \item $\Pi\iota\ p\ B$, an
    abstraction over a recursive occurence of
    the object being defined, with parameters $p$, of another operation
    $B$.
    \item $\iota\ p$, a constructor of the object being defined, with parameters $p$.
\end{itemize}
For example, the theory of natural numbers lives in the empty context has an
empty telescope of parameters. It is defined by
\begin{align*}
	&\mta{NatTh} : \mta{Theory}\ \bullet\ \bullet \\
	&\mta{NatTh} := \bullet \rhd \iota\ (\,) \rhd \Pi\iota\ (\,)\ (\iota\ (\,))
\end{align*}
We can add labels to aid readability, omitting parameters
if they are empty, and using $\Rightarrow$ for simple arrows:
\[
\mta{NatTh} := \bullet \rhd zero : \iota \rhd succ : \iota \Rightarrow \iota
\]
Notice that this syntax only allows occurrences of $\iota$ in positive
positions, which is a requirement for inductive types.
We could also add other constructors for operations. For example, we allow
external quantification in some other type theory, but we could also allow quantification
on the level of the \emph{metatheory} (ignoring size issues) by an operation
\[
\Pi_{\mta{meta}} : (A : \Set) \to (A \to \mta{Op}\ \Gamma\ P) \to \mta{Op}\ \Gamma\ P
\]
We do not require this kind of abstraction for this paper but different classes of
theories and quantification are explored in detail by Kov\'acs \cite{Kovacs2023-gq}.

In order to make use of our definition for theories, we would like to be able to interpret
the structure into a semantic universe. An algebra $(X, a) : \mta{Alg}\ T$
for a carrier $X$ and theory $T$ defines a way to interpret the structure of $T$
in terms of a type in a type theory $X : \mta{Ty}\ \Gamma$. This produces a type which
matches the structure of $T$ but replaces each occurrence of $\iota$ with $X$.
The function arrows in $T$ are interpreted as function arrows in the target universe.
Algebras for the theory of natural numbers might look like
\[
	\mta{Alg}\ \mta{NatTh}\simeq (X : \Ty\ \Gamma) \times (zero : \Tm\ \Gamma\ X) \times (succ : \Tm\ \Gamma\ (\Pi\ X\ X))
\]
We have a choice in terms of how much we want to interpret $T$ in the external type theory,
and how much we want to interpret it in the \emph{metatheory}. Here we have chosen to interpret
a theory as a metatheoretical iterated pair type, but an operation as a term in the type theory.

Very special classes of algebras support \emph{induction}.
To formulate induction, we first need to define displayed algebras.
A displayed algebra $(M, m)$ over an algebra $(X, a)$ for a theory $T$ with
carrier $M$ mirrors the shape of $T$ like an algebra does, but each recursive
occurrence $\iota$ is now replaced by $M$ applied to the corresponding value of
the algebra. The displayed algebras for natural numbers are
\begin{align*}
	\mta{DispAlg}\ (X, zero, succ) & \simeq (M : \Ty\ (\Gamma \rhd X))                                                      \\
	                               & \quad \times (zero' : \Tm\ \Gamma\ M[zero])                                            \\
	                               & \quad \times (succ' : \Tm\ \Gamma\ (\Pi\ (x : X)\ (\Pi\ M[x]\ M[\mta{app}\ succ\ x])))
\end{align*}
The type $M$ is often called the \emph{motive}, and $m$ the \emph{methods}.

\begin{definition}
An algebra is \emph{inductive} if every displayed algebra over it has a section.
\end{definition}
A section is a dependent function from $X$ to $M$ which takes its values from
the displayed algebra. For natural numebrs,
\begin{align*}
	\mta{Section}\  & \{(X, zero, succ)\}\ (M, zero', succ')                                                                                           \\
	                & \simeq (f : \Tm\ \Gamma\ (\Pi\ (x : X)\ M[x]))                                                                                   \\
	                & \quad \times (\mta{app}\ f\ zero = zero')                                                                                        \\
	                & \quad \times ((x : \Tm\ \Gamma\ X) \to \mta{app}\ f\ (\mta{app}\ succ\ x) = \mta{app}\ (\mta{app}\ succ'\ x)\ (\mta{app}\ f\ x))
\end{align*}
A section is the output of induction: a proof of $M$ for all $X$.

\subsection{Internal and external constructions}

For the remainder of the paper we choose a fixed representation for algebras,
displayed algebras and sections. We will omit the full definitions here for
space, but they can be found in \cref{app:algebras} of the appendix.

First, we define an `external' version of algebras
\begin{align*}
    &\mta{Alg}\ T := (X : \Ty\ \Gamma) \times \mta{Algebra}\ T\ X \\
    &\mta{Algebra}\ T\ X := (a : \mta{Args}\ T\ X) \to \Tm\ \Gamma\ X[\Msub{\mta{out}\ a}] \,.
\end{align*}
which takes some arguments $\mta{Args}$ and produces the output $X$
evaluated at the appropriate index $\mta{out}\ a$ based on the arguments. The
type $\mta{Args}$ is defined as $(v : \mta{Var}\ T) \times \Tms\ \Gamma\
(\mta{argsFor}\ (T\ v)\ X)$ for a type $\mta{Var}\ T$ which indexes operations
in theories, where
\begin{align*}
    &\mta{argsFor} : \mta{Op}\ \Gamma\ T \to \Ty\ \Gamma \to \Tel\ \Gamma \\
    &\mta{argsFor}\ (\Pi\ A\ B)\ X := \bullet \rhd (a : A) \rhd \mta{argsFor}\ B[\Msub a]\ X \\
    &\mta{argsFor}\ (\Pi\iota\ p\ B)\ X := \bullet \rhd X[\Msub p] \rhd \mta{argsFor}\ B\ X \\
    &\mta{argsFor}\ (\iota\ p)\ X := \bullet
\end{align*}
and $\mta{out}$ is defined as $\mta{outFor}\ \{T\ v\}\ a\ X$ where
\begin{align*}
    &\mta{outFor} : \{T : \Theory\ \Gamma\ P\} \to \Tms\ \Gamma\ (\mta{argsFor}\ O\ X) \to \Ty\ \Gamma \to \Tms\ \Gamma\ P \\
    &\mta{outFor} : \mta{Op}\ \Gamma\ T \to \Ty\ \Gamma \to \Tel\ \Gamma \\
    &\mta{outFor}\ \{\Pi\ A\ B\}\ (a, t)\ X := \mta{outFor}\ \{B[\Msub a]\}\ t\ X \\
    &\mta{outFor}\ \{\Pi\iota\ p\ B\}\ (r, t)\ X := \mta{outFor}\ \{B\}\ t\ X \\
    &\mta{outFor}\ \{\iota\ p\}\ (\,)\ X := p \,.
\end{align*}
We can also define a fully-internal version of algebras $\mta{algebra}\ T\ X$ as $\mta{Var}\ T$-indexed telescopes of
\begin{align*}
    &\mta{algebraFor} : \mta{Op}\ \Gamma\ T \to \Ty\ \Gamma \to \Ty\ \Gamma \\
    &\mta{algebraFor}\ (\Pi\ A\ B)\ X := \Pi\ (a : A)\ (\mta{algebraFor}\ B[\Msub a]\ X) \\
    &\mta{algebraFor}\ (\Pi\iota\ p\ B)\ X := \Pi\ X[\Msub p]\ (\mta{algebraFor}\ B\ X) \\
    &\mta{algebraFor}\ (\iota\ p)\ X := X[\Msub p] \,.
\end{align*}
which has evident `realisation' functions into the metatheory
\begin{align*}
    &\emb{\_} : \Tms\ \Gamma\ (\mta{alg}\ T) \to \mta{Alg}\ T \\
    &\emb{\_} : \Tms\ \Gamma\ (\mta{algebra}\ T\ X) \to \mta{Algebra}\ T\ X \,.
\end{align*}

% We can similarly define internal displayed algebras over external algebras $(X,
% x) : \mta{Alg}\ T$ as
% \begin{align*}
%     &\mta{dispAlgebra}\ (X, x) : \Tel\ (\Gamma \rhd M : \Ty\ (\Gamma \rhd P \rhd X)) \\
%     &\mta{dispAlg}\ (X, x) := \bullet \rhd M : \Ty\ (\Gamma \rhd P \rhd X) \rhd \mta{dispAlgebra}\ (X, x)
% \end{align*}
% and finally sections as
% \begin{align*}
%     &\mta{Sec}\ M := \Tm\ (\Gamma \rhd P \rhd X)\ M \\
%     &\mta{Coh}\ f := \forall a. f[\Msub{\mta{out}\ a; x\ a}] = m\ (\mta{disp}\ f\ a) \\
%     &\mta{Section}\ (M, m) := (f : \mta{Sec}\ M) \times \mta{Coh}\ f
% \end{align*}

A similar construction can be performed for displayed algebras over external algebras
\begin{align*}
&\mta{dispAlgebra}\ (X, x)\ M : \Tel\ \Gamma \\
&\mta{DispAlg}\ (X, x) := (M : \mta{Ty}\ (\Gamma \rhd P \rhd X)) \times \mta{Tms}\ \Gamma\ (\mta{dispAlgebra}\ (X, x)\ M)
\end{align*}
and we can use the realisation function for algebras to get internal displayed
algebras over internal algebras
\begin{align*}
    &\mta{dispAlg} : \Tel\ (\Gamma \rhd \mta{alg}\ T) \\
    &\mta{dispAlg} := a.\ \bullet \rhd (M : \Pi\ P\ (\Pi\ X\ \univ)) \rhd \mta{dispAlgebra}\ \emb{a}\ (\mta{El}\ M@@) \,.
\end{align*}
with evident realisation functions
\begin{align*}
    &\emb{\_} : \Tms\ \Gamma\ (\mta{dispAlg}[\Msub{t}]) \to \mta{DispAlg}\ \emb t \\
    &\emb{\_} : \Tms\ \Gamma\ (\mta{dispAlgebra}\ t\ M) \to \mta{DispAlgebra}\ t\ M \,.
\end{align*}

Finally, we can get external sections over displayed algebras
\begin{align*}
     &\mta{Sec}\ M := \Tm\ (\Gamma \rhd P \rhd X)\ M \\
     &\mta{Coh}\ f := \forall a. f[\Msub{\mta{out}\ a; x\ a}] = \mta{apply}\ m\ f\ a \\
     &\mta{IntCoh}\ f := \forall a. \Tm\ \Gamma\ (\mta{Id}\ f[\Msub{\mta{out}\ a; x\ a}]\ (\mta{apply}\ m\ f\ a)) \\
     &\mta{Section}\ (M, m) := (f : \mta{Sec}\ M) \times \mta{Coh}\ f
\end{align*}
which have coherence rules using either the equality of the metatheory (\mta{Coh}) or
the propositional equality of the type theory (\mta{IntCoh}).
The $\mta{apply}$ function takes a displayed algebra, a section, and some
arguments $\mta{Args}$, and evaluates the section at those arguments.

These also have internal analogues
\begin{align*}
    &\mta{sec} : \Tel\ (\Gamma \rhd \mta{alg}\ T \rhd \mta{dispAlg}) \\
    &\mta{sec} := X\ x\ M\ m.\ \Pi\ P\ (\Pi\ X\ M) \\[1em]
    &\mta{coh} : \Tel\ (\Gamma \rhd (X, x) : \mta{alg}\ T\rhd (M, m) : \mta{dispAlg} \rhd \Pi\ P\ (\Pi\ X\ M)) \\[1em]
    &\mta{section} : \Tel\ (\Gamma \rhd \mta{alg}\ T \rhd \mta{dispAlg}) \\
    &\mta{section} := X\ x\ M\ m.\ \mta{sec} \rhd \mta{coh}
\end{align*}
which only use propositional equality.

Once again, we can define realisation functions
\begin{align*}
    &\emb{\_}_0 : \Tms\ \Gamma\ (\mta{section}[\Msub{t},\Msub{m}]) \to \mta{Sec}\ \emb{m} \\
    &\emb{\_}_1 : (t : \Tms\ \Gamma\ (\mta{section}[\Msub{t},\Msub{m}])) \to \mta{IntCoh}\ \emb{t}_0
\end{align*}
which produce only internal coherence proofs.

Later we will make use of the external versions of algebras, displayed algebras,
and sections in order to `freely' add inductive algebras to the inductive syntax
of a type theory in a strictly-positive but fully-applied manner. On the other
hand, we will make use of the internal versions in order to be able to package
inductive algebras as a single syntactic entity that corresponds to data
representations.

\subsection{The core language, $\lambdaind$}\label{sub:lambdaind}

The languge $\lambdaind$, is a dependent type theory with $\Pi$, $\mta{Id}$, and
a universe $\univ$.
It also has inductive families and global definitions. We follow a similar
approach to Cockx~and~Abel~\cite{Cockx2018-fk} by packaging named inductive
constructions and function definitions into a signature $\Sigma : \Sig$, and
indexing contexts by signatures. The contexts $\Con$ in the resulting theory are
pairs $(\Sigma : \Sig) \times \Loc\ \Sigma$ where $\Loc\ \Sigma$ are local
contexts given by a closed telescope of types as usual. Items in a signature
$\Sigma$ can be either

\begin{itemize}
	\item function definitions $\mta{def}\ P\ A\ t$ for some parameters $P : \Loc\
		      \Sigma$, return type $A : \Ty\ (\Sigma, P)$ and implementation $t : \Tm\ A\ (\Sigma, P)$,
	\item postulates $\mta{post}\ P\ A$ for some parameters $P : \Loc\
		      \Sigma$ and return type $A : \Ty\ (\Sigma, P)$, or
	\item inductive type definitions $\mta{data}\ P\ T$ for some indices $P :
		      \Loc\ \Sigma$ and theory $T : \Theory\ (\Sigma, \bullet)\ P$.
\end{itemize}

The $\Theory\ \Gamma\ P$ sort stands for the contexts $\Con_{\mathbb{A}\ \Gamma\
		P}$ of a theory of positive signatures \cite{Kovacs2023-gq} $\mathbb{A}$ indexed
by contexts $\Gamma$ and telescopes $P$ in $\lambdaind$. In particular,
$\mathbb{A}\ \Gamma\ P$ describes positive signatures for a single family of
sorts $\iota : \Tms\ \Gamma\ P \to \Ty_{\mathbb{A}\ \Gamma\ P}$. An inductive
family can be defined as a context in this theory like $\bullet \rhd zero :
	\iota \rhd succ:\iota \Rightarrow \iota$. This context is allowed to reference
types in $\lambdaind$ from context $\Gamma$ and must apply $\iota$ to a spine of
parameters $P$. The $\mta{data}$ definition packages the parameters $P$ and the
context for the inductive family being defined. For vectors this would be
\begin{align*}
	 & \mta{Vect} : \mta{data}                                                                                                        \\
	 & \quad\begin{aligned}
		        \quad (\bullet & \rhd\univ \rhd \mta{Nat})\                                                                               \\
		        \quad (\bullet & \rhd nil : (T : \univ) \to \iota\ T\ \mta{zero}                                                          \\
		        \quad          & \rhd cons : (T : \univ) \to (n : \mta{Nat}) \to \iota\ T\ n \Rightarrow T \to \iota\ T\ (\mta{succ}\ n))
	        \end{aligned}
\end{align*}
The function arrows $\to$ and $\Rightarrow$ are different because the former
denotes abstraction over an external type (from $\Ty\ \Gamma$) and the latter a
recursive occurence of the inductive type being defined (with indices from
$\Tms\ \Gamma\ P$). All function arrows must eventually return $\iota\ p$ for
some $p : \Tms\ \Gamma\ P$


In order to actually construct inductive types in $\lambdaind$, we need to
extend the syntax with some term and type formers. First, we add a type former
\[
	\mta{D} : \mta{data}\ P\ T \in \Sigma \to \Ty\ (\Sigma, \Delta \rhd P)
\]
which, given a data definition $i$ in $\Sigma$, and terms for its
indices $p$, constructs the data type $(\mta{D}\ i)[p]$. The relation $I \in
	\Sigma$ should be thought of as `variables for item $I$ in a signature
$\Sigma$', in a similar way to how $\mta{Var}\ \Gamma\ A$ defines variables for
type $A$ in a local context $\Gamma$.


Additionally, we add a constructor term
\[
	\mta{C} :\ \forall i.\ \mta{Algebra}\ T\ (\mta{D}\ i)
\]
which fully applied, defines the data constructor $\mta{C}\ a$ of type
$(\mta{D}\ i)[\Msub p]$ for arguments $a$.
% The type $\mta{Args}\ T\ X$ is defined such
% that
% \begin{equation}
% 	\mta{isAlgebra} : ((a : \mta{Args}\ T\ X) \to \Tm\ \Gamma\ X[\Msub{\mta{out}\ a}]) \simeq \mta{Algebra}\ T\ X \,.\label{eq:args-iso}
% \end{equation}
% This is possible because the algebras for a theory $T$ over $\mta{D}\ i\ p$ are
% described by a metatheoretic product of internal curried functions ending in
% $\mta{D}\ i$, which is equivalent to a function out of a coproduct
% $\mta{Args}\ i$ into $\mta{D}\ i$. All occurences of $\mta{Tm}$ in
% $\mta{Args}$ occur positively and are part of the inductive syntax.
% $\mta{Args}$ is also a functor in $X$ by

\begin{definition}
	The \emph{internal term algebra} of a data type $i$ is $\mta{C}_i$.
\end{definition}



% From now we will use $\mta{isAlgebra}$ implicitly when applying an algebra to
% some arguments.

Finally, we add an eliminator term
\[
	\mta{E} :\ \forall i.\ (m : \mta{DispAlg}\ \mta{C}) \to \mta{Sec}\ m
\]
which given a data definition $i$ in $\Sigma$, a motive and methods for $i$,
eliminates each $d : (\mta{D}\ i)[\Msub p]$ into $M[\Msub{p;d}]$. This captures
the induction principle of the data type. The coherence part of the section is
captured by an equality constructor
\[
	\mta{E-id} :\ \forall i.\ (m : \mta{DispAlg}\ \mta{C}) \to \mta{Coh}\ (\mta{E}\ m)
\]
% The type $\mta{Methods}$ describes displayed algebras of the internal term algebra.
% It has an accompanying function $\mta{applyDisp}$ with the form
% \begin{align*}
%     \mta{applyDisp} :\ \forall M\ l.\ &(m : \mta{Methods}\ l\ M) \to (s : \Tm\ (\Gamma \rhd P \rhd X)\ M) \\
%     &\to (a : \mta{Args}\ T\ X) \\
%     &\to \Tm\ \Gamma\ (M[\Msub{\mta{out}\ a; l\ a}]
% \end{align*}
% which applies the arguments $a$ to the appropriate method in $m$, sampling the inductive hypothesis
% from the section $s$.
% The output of the eliminator paired with the $\mta{E-id}$ equality
% constructor defines a section of this displayed algebra
% \begin{align*}
%     \mta{isSection}\ M\ m :\ & (f : \Tm\ (\Gamma \rhd P \rhd X)\ M) \\
%     &\quad\times (\forall a.\ f\ [\Msub{\mta{out}\ a;l\ a}] = \mta{applyDisp}\ m\ f\ a) \\
%     &\simeq \mta{Section}\ (M,\ m)
% \end{align*}

\begin{lemma}
	The internal term algebra of a data type $i$ is inductive.
	\begin{proof}
		For every displayed algebra $m$ over $\mta{C}$ we get a section $(\mta{E}\ m, \mta{E-id}\ m)$.
	\end{proof}
\end{lemma}

% \begin{definition}
% A \emph{representation} of a theory $T$ is an algebra $(R, r)$ of the theory $T$ which supports induction.
% \end{definition}

\subsection{Extending $\lambdaind$ with representations} \label{sub:lambdarep}

We extend the language $\lambdaind$ to form $\lambdarep$, which allows users to
define custom representations for inductive types and global functions.

\begin{definition}
	A representation of an inductive type $\mta{data}\ P\ T$ is an inductive algebra for $T$.
\end{definition}

We modify the syntax for signatures $\Sig$ to introduce representations:
\begin{align*}
	 & \bullet : \Sig \\
	 & \rhd : (\Sigma : \Sig) \to \Item\ \Sigma \to \Sig \\
	 & \unrhd : (\Sigma : \Sig) \to (I : \Item\ \Sigma) \to \Rep\ \Sigma\ I \to \Sig \,.
\end{align*}
Representations in turn are defined as
\begin{align*}
& \Rep : (\Sigma : \Sig) \to \Item\ \Sigma \to \Set \\
& \mta{data-rep} : \Tms\ (\Sigma, \epsilon)\ (\mta{inductiveAlg}\ T) \to \Rep\ \Sigma\ (\mta{data}\ P\ T) \\
& \mta{def-rep} : (x : \Tm\ (\Sigma, P)\ A) \to \Tm\ (\Sigma, P)\ (\mta{Id}\ x\ t) \to \Rep\ \Sigma\ (\mta{def}\ P\ A\ t)
\end{align*}
Data types are represented by providing an inductive algebra for their theory.
We write $\mta{data-rep}\ (R, r, Q)$ for a data representation with carrier $R :
\Tm\ (\Sigma, \epsilon)\ (\Pi\ P\ \univ)$, algebra $r : \Tm\ (\Sigma, \epsilon)\ (\mta{algebra}[\Msub R])$,
and induction $Q : \Tm\ (\Sigma, \epsilon)\ ((\Pi\ \mta{dispAlg}\ \mta{section})[\Msub{R, r}])$.

We also include representations for definitions, where a definition can be
represented by a term propositionally equal to original definition, but perhaps
with better computational properties.
We can define a decidable relation $R \in_i \Sigma'$ to mean that $R :
\mta{Rep}\ \Sigma\ I$ is the representation of an item $I : \mta{Item}\ \Sigma$
where $i : I \in \Sigma'$.
This relation is a proposition, so it is proof-irrelevant. Furthermore, it is stable under
weakening of contexts and signatures, because each item can only be represented once in a signature.



To allow reasoning about representations in $\lambdarep$ we add a type former
\begin{equation}\label{eq:repr-ty}
	\MRepr{} : \Ty\ \Gamma \to \Ty\ \Gamma
\end{equation}
along with two new terms in the syntax, forming an isomorphism
\begin{equation}\label{eq:repr-iso}
	\Mrepr{} : \Tm\ \Gamma\ T \simeq \Tm\ \Gamma\ (\MRepr\ T) : \Munrepr{} \,.
\end{equation}
which holds definitionally and preserves $\Pi$, $\mta{Id}$ and universes. The
type $\MRepr\ T$ is the defined representation of the type $T$. The term
$\Mrepr{}$ takes a term of type $T$ to its representation of type $\MRepr\ T$,
and $\Munrepr{}$ undoes the
effect of $\Mrepr{}$, treating a represented term as an inhabitant of its
original type. These new constructs come with equality constructors in the syntax
shown in \cref{fig:lambdaind-repr-coherence-pi-univ}.



\begin{figure}[H]
  \begin{minipage}[t]{0.5\textwidth}%
  \begin{alignat*}{2}
  & \mta{reprr} &&: \Munrepr\ (\Mrepr\ t) \equiv t \\
  & \mta{reprl} &&: \Mrepr\ (\Munrepr\ t) \equiv t \\[1em]
  & \MRepr\text{-}\Pi &&: \MRepr\ {(\Pi\ T\ U)} \equiv \Pi\ T\ (\MRepr\ U) \\
  & \Mrepr\text{-}\lambda &&: \Mrepr\ {(\lambda\ u)} \equiv \lambda\ (\Mrepr\ u) \\
  & \Munrepr\text{-}\lambda &&: \Munrepr\ {(\lambda\ u)} \equiv \lambda\ (\Munrepr\ u) \\
  & \Mrepr\text{-}@ &&: \Mrepr\ (\ap f) \equiv \ap {(\Mrepr\ f)} \\
  & \Munrepr\text{-}@ &&: \Munrepr\ (\ap f) \equiv \ap {(\Munrepr\ f)}
  \end{alignat*}
  \end{minipage}%
  \begin{minipage}[t]{0.5\textwidth}%
  \begin{alignat*}{2}
  & \MRepr\text{-}\univ &&: \MRepr\ {\univ} \equiv \univ \\
  & \Mrepr\text{-}\Code{} &&: \Mrepr\ {(\Code T)} \equiv \Code T \\
  & \Munrepr\text{-}\Code{} &&: \Munrepr\ {(\Code T)} \equiv \Code T \\[1em]
  & \MRepr[] &&: \MRepr\ {(T[\sigma])} \equiv (\MRepr\ {T})[\sigma] \\
  & \Mrepr[] &&: \Mrepr\ {(t[\sigma])} \equiv (\Mrepr\ {t})[\sigma] \\
  & \Munrepr[] &&: \Munrepr\ {(t[\sigma])} \equiv (\Munrepr\ {t})[\sigma]
  \end{alignat*}
  \end{minipage}%
  \caption{Coherence of the representation operators with substitutions, $\Pi$-types and
  universes. The terms $\MRepr\ (\El{t})$, $\Mrepr\ (\pi_2 \sigma)$ and
  $\Munrepr\ (\pi_2 \sigma)$ do not reduce.}
  \label{fig:lambdaind-repr-coherence-pi-univ}
\end{figure}


So far the representation operators do not really do anything. In order to make
them useful, we need to define how they compute when they encounter data types
which are represented in the signature.
In the following rules, $r : \mta{data-rep}\ (R, r, Q) \in_i \Sigma$.
Firstly, we define the reduction that occurs when a type $\mta{D}\ i$ is represented,
\begin{equation}
  \mta{Repr-D} : \forall r.\ \MRepr\ (\mta{D}\ i) = \emb{R} \,, \label{eq:lambdaind-Repr-D}
\end{equation}
yielding the carrier $R$ of the inductive algebra that represents it.
Additionally, we can add a similar rule for constructors, albeit in propositional form, where
\begin{align*}
&\mta{repr-C} : \forall r.\ \Tm\ (\Sigma, \Delta)\ (\mta{Id}\ (\Mrepr\ (\mta{C}\ a))\ (\emb{r}\ a^\mta{Repr}))
\end{align*}
Here, the `fmap' operator $\fmap$ is used to apply the term former $\mta{repr}$
to the recursive part of the arguments of $a$. This is definable because
$\mta{Args}\ T\ X$ is natural in $X$ as it is a sum of products.

One might be tempted to make this equality definitional too. Unfortunately, this
would render conversion checking undecidable, because if one applies
$\mta{unrepr}$ to a term $\Mrepr\ (\mta{C}\ a)$ which has already been reduced
to its representation, $\mta{unrepr}\ (\emb{r}\ a^{\mta{Repr}})$, there is no
clear way to decide that this is convertible to $\mta{C}\ a$ even though the
definitional equality rules would imply that it is (due
to the annihilation of $\mta{repr}$ and $\mta{unrepr}$). There is no
equivalent of $\mta{unrepr}$ for types, so \eqref{eq:lambdaind-Repr-D} preserves
the decidability of conversion checking.


We can also add a propositional equality rules for representing eliminators.
First, representing an eliminator just applies $\mta{repr}$ to the motive and methods:
\begin{align*}
&\mta{repr-motive-E} : \forall r.\ \Tm\ (\Sigma, \Delta)\ (\mta{Id}\ (\Mrepr\ (\mta{E}\ m))\ (\mta{E}\ m^\mta{Repr})) \\
&\mta{unrepr-motive-E} : \forall r.\ \Tm\ (\Sigma, \Delta)\ (\mta{Id}\ (\Munrepr\ (\mta{E}\ m))\ (\mta{E}\ m^\mta{Unrepr}))
\end{align*}
Additionally, eliminating something using $\mta{E}$ should be the same as
eliminating the representation of that thing using the represented eliminator $Q$:
\begin{align*}
&\mta{repr-methods-E} : \forall r.\ \Tm\ (\Sigma, \Delta)\ (\mta{Id}\ (\mta{E}\ m)\ (s.\ (\emb{Q}_0\ m^{\mta{Repr*}})[\Msub{\mta{repr}\ s}]))) \\
\end{align*}
\begin{align*}
\_^{\mta{Repr}} &: \mta{Algebra}\ T\ X \to \mta{Algebra}\ T\ (\mta{Repr}\ X) \\
 \_^{\mta{Repr}} &: \mta{DispAlgebra}\ a\ M \to \mta{DispAlg}\ a\ (\MRepr\ M) \\
 \_^{\mta{Repr}*} &: \mta{DispAlgebra}\ a\ M \to \mta{DispAlg}\ a^{\mta{Repr}}\ (p\ x .\ M[\Msub{p;\mta{unrepr}\ x}])
\end{align*}
% Here, the \mta{Unrepr} operations are typed as
% \begin{align*}
% &\_^{\mta{Unrepr}} : \Ty\ (\Gamma \rhd P \rhd \mta{D}\ i) \to \Ty\ (\Gamma \rhd P \rhd R) \\
% &\_^{\mta{Unrepr}} : \mta{Methods}\ M \to \mta{Methods}\ M^{\mta{Unrepr}}\,.
% \end{align*}
% The first one takes a motive over $\mta{D}\ i$ and produces a motive over $R$ by applying
% \mta{unrepr} to the $\mta{D}\ i$ in the context, while the second one takes some
% methods over $\mta{D}\ i$ and produces methods over $R$ by applying
% $\mta{unrepr}$ to all recursive arguments in the context, and then applying
% $\mta{repr}$ to the result to obtain an inhabitant of $M^{\mta{Unrepr}}$.

Now we state some basic lemmas of the representation operators.

\begin{lemma}
	The term formers $\Mrepr{}$ and $\Munrepr{}$ are injective, i.e.
	$\Mrepr\ x = \Mrepr\ y \to x = y$ and $\Munrepr\ x = \Munrepr\ y \to x = y$.
	\begin{proof}
				By applying $\mta{unrepr}/\mta{repr}$ to both sides
				followed by the rule $\mta{reprr}/\mta{reprl}$.
	\end{proof}
\end{lemma}


\section{Translating from $\lambdarep$ to $\lambdaind$}



We can define a translation step $\R$ from $\lambdarep$ to
$\lambdaind^{\textsc{Ext}}$, meant to be applied during the compilation process.
More specifically, the translation target is the extensional flavour of
$\lambdaind$ by adding the equality reflection rule. We do this by translating
well-formed contexts, substitutions, types, and terms in a mutual manner such
that definitional equality is preserved.
$\R$ preserves the structure of
$\lambdarep$, but maps constructs to their terminal representations.
First, we define a translation of signatures
\begin{align*}
& \R : \Sig_\rep \to \Sig_\ind \\
& \R\ \bullet := \bullet \\
& \R\ (\Sigma \rhd I) := \R \Sigma \rhd \R I \\
& \R\ (\Sigma \unrhd I \ R) := \R \Sigma
\end{align*}
which erases all items with defined representations.
This uses a translation of items
\begin{align*}
& \R : \Item_\rep\ \Sigma \to \Item_\ind\ \R \Sigma
\end{align*}
which simply recurses on all constructors. Types are translated as
\begin{align*}
  & \R : \Ty_\rep\ (\Sigma, \Delta)\ \to \Ty_\ind\ (\R \Sigma, \R \Delta) \\
  & \R\ (\mta{D}\ i) := \kwd{if}\ \mta{data-rep}\ (R, r, Q) \in_i \Sigma\ \kwd{then}\ \emb{\R R}\ \kwd{else}\ \mta{D}\ \R i \\
  & \R\ (\MRepr\ T) := \R T \\
  & \text{(otherwise recurse on all subterms with $\R$)}
\end{align*}
and terms are translated as
\begin{align*}
  & \R : \Tm_\rep\ (\Sigma, \Delta)\ T \to \Tm_\ind\ (\R \Sigma, \R \Delta)\ \R T \\
  & \R\ (\mta{C}_i\ a) := \kwd{if}\ \mta{data-rep}\ (R, r, Q) \in_i \Sigma\ \\
    &\qquad \kwd{then}\ \emb{\R r}\ \R a\ \kwd{else}\ \mta{C}_{\R i}\ \R a \\
  & \R\ (\mta{E}_i\ m) :=  \kwd{if}\ \mta{data-rep}\ (R, r, Q) \in_i \Sigma\ \\
    &\qquad \kwd{then}\ \emb{\R Q}_0\ \R m\ \kwd{else}\ \mta{E}_{\R i}\ \R m \\
  & \R\ (\Mrepr\ t) := \R t \\
  & \R\ (\Munrepr\ t) := \R t \\
  & \R\ (\mta{repr-C}_i\ a) := \mta{refl} \\
  & \R\ (\mta{repr-motive-E}_i\ m) := \mta{refl} \\
  & \R\ (\mta{unrepr-motive-E}_i\ m) := \mta{refl} \\
  & \R\ (\mta{repr-methods-E}_i\ m) := \mta{refl} \\
  & \text{(otherwise recurse on all subterms with $\R$)}
\end{align*}

The definitional coherence rules for representation operators
\cref{fig:lambdaind-repr-coherence-pi-univ} are preserved by metatheoretic
reflexivity on the other side, since all representation operators are erased.
The coherence rules for eliminators $\mta{E}$ are preserved by reflecting the
propositional coherence rules provided by the defined representations:
\begin{align*}
& \mta{ap}_\R\ (\mta{E-id}_i\ m) :=  \kwd{if}\ \mta{data-rep}\ (R, r)\ Q \in_i \Sigma\ \\
      &\qquad \kwd{then}\ \mta{reflect}\ \emb{\R Q}_1\ \R m\ \kwd{else}\ \mta{E-id}_{\R i}\ \R m  \\
& \text{(otherwise recurse on all equality constructors with $\mta{ap}_\R$)}
\end{align*}

By construction, $\R$ is sound with respect to typing and definitional equality.

\subsection{Computational irrelevance}

In order to reason about computational irrelevance, we assume that there is
an additional program extraction step $\mathcal{E}$ from $\lambdaind$ into some
simply-typed calculus $\lambda$, denoted by vertical bars $|x|$. As opposed to
$\R$, $\mathcal{E}$ operates on the unquotiented syntax of $\lambdaind$. This
can be justified by interpreting the quotient-inductive constructions from
before into setoids. This kind of
transformation is used because we might want to compile two definitionally equal
terms differently. For example, we might not always want to reduce function
application redexes. We will use the \texttt{monospace} font for terms in
$\lambda$.

\begin{definition}
    An function $f : \mta{Tm}_\rep\ \Gamma\ (\Pi\ A\ B)$, is \emph{computationally irrelevant} if
    $|\R A| = |\R B|$ and $|\R f| = \texttt{id}$ for all $a : \mta{Tm}\ \Gamma\ A$.
\end{definition}

\begin{lemma}
	The type former $\MRepr{}$ is injective up to internal isomorphism, i.e.
	\begin{equation}
	\mta{Repr}\ T = \mta{Repr}\ T' \to \Tm\ \Gamma\ (\mta{Iso}\ T\ T')
	\end{equation}
	Moreover, this isomorphism is computationally irrelevant.
	\begin{proof}
	The forward direction is given by first applying $\mta{repr}$ to $t$,
	transporting over the equality and then applying $\mta{unrepr}$. The
	backward direction is given by applying $\mta{repr}$ to $t'$, transporting
	over the equality and then applying $\mta{unrepr}$. The coherence holds by
	the rules $\mta{reprr}$ and $\mta{reprl}$. After applying $\R$, all
	representation operators are erased and the isomorphism is the identity on both
	sides (even before extraction).
	\end{proof}
\end{lemma}


We will prove some desired properties
of $\R$ \cite{Boulier2017-cm} such as typing and computational soundness, and
preservation of consistency. The final program can then be converted into a
simply-typed language which erases irrelevant data. We can recover a program in
$\lambdaind$ by translating extensional typing derivations to intensional proofs
\cite{Winterhalter2019-zw}.
\cite{Winterhalter2019-zw}.
