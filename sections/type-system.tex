\newcommand{\lambdaprim}{\lambda_{\textsc{prim}}}
\newcommand{\lambdaind}{\lambda_{\textsc{ind}}}
\newcommand{\lambdarep}{\lambda_{\textsc{rep}}}

\newcommand{\lab}[1]{{\ensuremath{\color{blue}{\mathsf{#1}}}}}
\newcommand{\kwd}[1]{\mta{\myuline{#1}}}
\newcommand{\Sdata}[2]{\kwd{data} \ \lab{#1} \, {#2} : \univ_1}
\newcommand{\Sctor}[4]{\kwd{ctor} \ \lab{#1} \, {#2} : \lab{#3}\, {#4}}
\newcommand{\Sctorvar}[4]{\kwd{ctor} \ #1 \, {#2} : \lab{#3}\, {#4}}
\newcommand{\Sfun}[3]{\kwd{fun} \ \lab{#1} : {#2} = {#3}}
\newcommand{\isConcrete}[1]{{#1}\ \inte{concrete}}
% \newcommand{\Srepr}[4]{\kwd{repr} \ \lab{#1} \ \kwd{for}\ \lab{#2}\, {#3}\ \kwd{as}\ {#4}}
% \newcommand{\Sreprconst}[3]{\kwd{repr} \ \lab{#1} \ \kwd{for}\ \lab{#2}\ \kwd{as}\ {#3}}
% \newcommand{\Sreprvar}[4]{\kwd{repr} \ \lab{#1} \ \kwd{for}\ {#2}\, {#3}\ \kwd{as}\ {#4}}
\newcommand{\Srepr}[4]{\kwd{repr} \ \lab{#2}\, {#3}\ \kwd{as}\ {#4}}
\newcommand{\Sreprconst}[3]{\kwd{repr} \ \lab{#2}\ \kwd{as}\ {#3}}
\newcommand{\Sreprvar}[4]{\kwd{repr} \ {#2}\, {#3}\ \kwd{as}\ {#4}}
\newcommand{\Sclosed}[2]{\kwd{closed}\ #1 \ #2}
\newcommand{\DeltaFor}[1]{\Delta_{\lab{#1}}}
\newcommand{\Trepr}[1]{\mta{repr}\, {#1}}
\newcommand{\TRepr}[1]{\mta{Repr}\, {#1}}
\newcommand{\Crepr}[1]{\text{$\Downarrow$} {#1}}
\newcommand{\crepr}[1]{\text{$\downarrow$} {#1}}
\newcommand{\isLabNotIn}[2]{\lab{#1}\ \inte{label} \notin {#2}}
\newcommand{\caselab}[1]{\lab{\textrm{case}_{#1}}}

\section{A type system for data representations}\label{sec:type-system}

In this section, we describe a type system for data representations in a staged
language. We start by defining a core staged language $\lambdaprim$ with
$\Sigma$/$\Pi$-types, identity types, and a universe of types $\univ_i$ for
each stage $i$, as well as a set of object-level machine primitives. We then
introduce inductive constructions in the meta-fragment of $\lambdaprim$ to form
$\lambdaind$. Finally, we introduce data representations in $\lambdaind$ and
extend the system with rules for data representations in $\lambdarep$. Since
staged dependent type systems and inductive constructions are well understood,
we will focus on the novel aspects of data representations. The languages above
form an inclusion hierarchy
\[
  \lambdaprim \subset \lambdaind \subset \lambdarep
\]
and our goal is to describe a transformation from $\lambdarep$ to
$\lambdaprim$, elaborating away inductive definitions with the help of data
representations. Finally, the resulting program in $\lambdaprim$ can be staged
to the purely object-level language that represents the target architecture.

When defining these languages, we will use a BNF-like syntax for terms and
contexts, natural deduction-style typing rules, as well as CWF-style notation
for contexts, types, and terms. (TODO: expand!)

\subsection{A core staged language with machine primitives, $\lambdaprim$}
\newcommand{\seq}[2]{[#1; #2]}

As a first step towards a type system for data representations, we informally
describe a staged dependent type system $\lambdaprim$ with
$\Sigma$/$\Pi$-types, identity types, and a universe of types $\univ_i$ for
each stage $i \in \{0, 1\}$. This serves as a background system on which we
introduce inductive constructions and data representations in. The raw syntax
of $\lambdaprim$ is given by the BNF grammar
\[
  t ::= \univ_i \mid x \mapsto t \mid t \, t \mid x \mid (x : t) \to t \mid (x : t) \times t \mid
  \Id{A}{a}{b} \mid \pi_1 \, t \mid \pi_2 \, t \mid \mta{refl} \mid \lift t \mid \quot t \mid \splice t
\]
This follows the standard typing rules of 2LTT with $\Sigma$, $\Pi$ and
identity types \cite{Kovacs2022-vb}, without regard for the universe hierarchy,
as this is orthogonal to the main focus of this work. Notably, $\univ_0 :
  \univ_0$ is the object-level universe, and $\univ_1 : \univ_1$ is the
meta-level universe. We will use $\mta{let}_i$ notation for binding, though
this is just syntactic sugar for redexes.

On top of this base syntax, we assume a certain set of primitives that exist in
the object language. These will be used to form data representations. They are
provided by the target architecture, which is represented by the object
language:
\begin{itemize}
  \item A type of booleans, $\inte{Bool} : \univ_0$, with constants $\inte{true} :
          \inte{Bool}$ and $\inte{false} : \inte{Bool}$, and operations $\inte{and}$,
        $\inte{or}$, and $\inte{not}$. Elimination for booleans is also provided, in
        the form of \[\inte{ifthenelse} : (b : \inte{Bool}) \to ((\Id{\inte{Bool}}{b}{\inte{true}}) \to A)
          \to ((\Id{\inte{Bool}}{b}{\inte{false}}) \to A) \to A.\]
  \item A type of machine words, $\inte{Word} : \univ_0$ with constants $0, 1, 2,
          \ldots$ and standard binary numeric operations $\inte{add}$, $\inte{sub}$,
        $\inte{mul}$, as well as $\inte{Bool}$-valued comparison operations
        $\inte{eq}$, $\inte{lt}$, and $\inte{gt}$. We will use the notation
        $\inte{Word}_n$ to denote the type $(w : \inte{Word}) \times
          \Id{\inte{Bool}}{\inte{lt} \, w \, n}{\inte{true}}$.
  \item A type of $n$-sized sequences of type $A$, $\seq{A}{n} : \univ_0$, where $n :
          \inte{Word}$ and $A : \univ_0$. Sequences come with indexing operations
        $\inte{get} : \seq{A}{n} \to \inte{Word}_n \to A$ and $\inte{set} : \seq{A}{n}
          \to \inte{Word}_n \to A \to \seq{A}{n}$. Sequences should be thought of as
        unboxed arrays, living on the stack.
  \item A boxing type constructor $\boxx A : \univ_0$ where $A : \univ_0$, with boxing
        and unboxing operations $\inbox a : \boxx A$ and $\unbox b : A$. Values of type
        $\boxx A$ represent explicitly heap-allocated values of type $A$.
\end{itemize}
These primitives do not necessarily form an exhaustive list; indeed, we will
sometimes expect further properties of these primitives to hold propositionally
in the form of additional primitive lemmas, such as
$(n : \inte{Word}) \to \Id{\inte{Word}}{\inte{add}\,0\,n}{n}$. Precise details are only necessary when
implementing such a system, and the definitions above are sufficient for the
present discussion.

\subsection{Extending $\lambdaprim$ with inductive constructions}

Building on top of $\lambdaprim$, we introduce an extension of the system for
named inductive constructions in the meta-language, called $\lambdaind$. First,
we present a raw syntax for signatures $\Sigma$ containing items $Z$ consisting
of data, constructor, and function definitions:
\begin{align*}
  \Sigma & ::= \cdot \mid \Sigma, Z                                                                                          \\
  Z      & ::= \Sdata{D}{\Delta} \mid \Sctor{C}{\Delta}{D}{\Delta} \mid \Sclosed{\lab{D}}{\vec{\lab{C}}} \mid \Sfun{f}{t}{t}
\end{align*}
The symbols in \textcolor{blue}{blue} represent labels, which are used to
uniquely identify elements of a signature.
A data definition $\Sdata{D}{\Delta}$ introduces a new inductive type $\lab{D}$
with a telescope $\Delta$ of arguments. A constructor definition
$\Sctor{C}{\DeltaFor{C}}{D}{\Delta}$ introduces a new constructor $\lab{C}$ for
the inductive type $\lab{D}$, with a telescope $\DeltaFor{C}$ of parameters
which may depend on $\lab{D}$'s parameters. Closed declarations $\Sclosed{\lab{D}}{\vec{\lab{C}}}$ specify that the
constructors $\vec{\lab{C}}$ are the only constructors for the inductive type
$\lab{D}$ in the present signature. A function definition
$\Sfun{f}{t}{t}$ introduces a new named function $\lab{f}$ of type $t$ and value
$t$.
The reason for including function definitions in a signature is to allow for
named functions in the meta-language, which can be overriden as part of data
representations.

The syntax for telescopes $\Delta$ is
\[
  \Delta ::= \cdot \mid \Delta, x : t \,,
\]
resembling the syntax for contexts, but restricted to meta-level types and
well-typed with respect to a context $\Gamma$, meaning that telescopes can
contain open terms. We use the notation $\Delta \to t$ to denote a repeated
function type with parameters from $\Delta$ and codomain $t$ which may depend
on the parameters. Additionally, we will sometimes explicitly bind the names of
a telescope such as $(\vec{x} : \Delta) \to t[\vec{x}]$. Similar syntax is used
to extend contexts with telescopes: $\Gamma, \Delta$ or $\Gamma, \vec{x} :
  \Delta$.

The syntax of terms must be extended accordingly with labels applied to
arguments
\[
  t ::= \ldots \mid \lab{L} \, \vec{t}
\]
where $\vec{t}$ denotes a sequence of terms and $\lab L$ refers to any valid
label in a signature (data, constructor, or function definitions). For example,
given a function
\[
  \Sfun{id}{(A : \univ_1) \to A \to A}{\_ \mapsto x \mapsto x}
\]
we can write $\lab{id} \, A \, a$ to denote the full application of the
identity function to a type $A$ and a term $a : A$. Partial applications are
also allowed as syntactic syntactic sugar, so that $\lab{id} \, A$ is shorthand
Each inductive definition $\Sdata{D}{\Delta}$ exposes an additional function
label $\caselab{D}$ which is used to perform case analysis on terms of the
inductive type $\lab{D}$. for $x \mapsto y \mapsto \lab{id} \, A \, x \, y$. As
such, valid labelled application terms in a signature are given through the
typing rules of $\lambdaind$ and do not correspond exactly to the labels
\emph{present} in the signature's items.

The language $\lambdaind$ is equipped with the following judgment forms:
\begin{itemize}
  \item $\Sigma \mid \Gamma \vdash \istype{i}{T}$ --- In signature $\Sigma$ and
        context $\Gamma$, $T$ is a well-formed type in stage $i$.
  \item $\Sigma \mid \Gamma \vdash a : T$ --- In signature $\Sigma$ and context
        $\Gamma$, $a$ is a well-formed term of type $T$.
  \item $Z \in \Sigma$ --- The item $Z$ is present in the signature $\Sigma$.
  \item $\Sigma \vdash Z$ --- The item $Z$ is well-formed in the signature $\Sigma$.
  \item $\isLabNotIn{L}{\Sigma}$ --- The label $\lab{L}$ does not appear in the
        signature $\Sigma$.
\end{itemize}

TODO: typing rules

\subsection{Data representations in $\lambdarep$}

So far, we have described $\lambdaind$, a dependently-typed staged language
with object-level machine primitives as well as named inductive constructions
and function definitions. We now introduce data representations in the
meta-language, forming the language $\lambdarep$. The goal of data
representations is to provide a way to represent data types, constructions, and
functions in a more efficient manner, by transforming them into more suitable
data structures for the target architecture. This is achieved by defining a new
kind of item in signatures, called a representation, which specifies how to
represent a given meta-level item in the object language. With no further
restrictions, a user would be able to arbitrarily change the semantics of the
meta-level items through representations, which would be undesirable. Instead,
we restrict data representations to preserve the intended semantics of the
original items, allowing for a correct-by-construction transformation from
$\lambdarep$ to $\lambdaprim$. This is done in different ways for data types,
constructors, and functions.

First, we extend the raw syntax of items $Z$ with representations, forming
$\lambdarep$:
\[
  Z ::= \ldots \mid \Srepr{R}{L}{\Delta}{t}
\]
A representation $\Srepr{R}{L}{\Delta}{t}$ asks for a definition $\lab{L}$ with
parameters $\Delta$ to be represented by a term $t$. Data, constructor and
function representations all share the same raw syntax and are distinguished by
the subject $L$. In the typing rules we will require that every meta-level type
$A$ has a defined representation $\Trepr{A}$. Extensions to this system could
support a sub-class of types with representations, retaining the ability to
have purely meta-level types with no defined representations. For this we
extend the raw syntax of terms to
\[
  t ::= \ldots \mid \Trepr{t} \mid \TRepr{t}
\]
where $\TRepr{A}$ is the representation of a type $A$ and $\Trepr{a}$ is the
representation of a term $a$, whose type is $\TRepr{A}$. With that, we can now
define the additional typing rules for $\lambdarep$, in
\cref{fig:lambdarep-rules}

\begin{figure}[h]
  \begin{mathpar}
    \inferrule[Repr-Ctor]
    {
      \Sdata{D}{\Delta} \in \Sigma     \\
      \forall i \in I .\ \Sctorvar{\lab{C}_i}{\Delta_{\lab{C}_i}}{D}{\Delta} \in \Sigma     \\
      \Srepr{R}{D}{\Crepr{\Delta}}{A} \in \Sigma \\
      \forall j < i .\ \Sreprvar{R}{\lab{C}_j}{\Crepr{\Delta_{\lab{C}_j}}}{t_j} \in \Sigma     \\
      \Sigma \mid \Crepr{\Delta},\Crepr{\DeltaFor{C}} \vdash t_i : (a : A) \times \textstyle \prod_{j < i} (a \neq \pi_1 t_j)
    }
    {\Sigma \vdash \Sreprvar{R}{\lab{C}_i}{\Crepr{\Delta_{\lab{C}_i}}}{t_i}} \and
    \inferrule[Repr-Case]
    {
    \Sdata{D}{\Delta} \in \Sigma     \\
    \Srepr{R}{D}{\Crepr{\Delta}}{A} \in \Sigma \\
    \forall i \in I .\ \Sctorvar{\lab{C}_{i}}{\Delta_{\lab{C}_i}}{D}{\Delta} \in \Sigma     \\
    \forall i \in I .\ \Sreprvar{R}{\lab{C}_i}{\Crepr{\Delta_{\lab{C}_i}}}{t_i} \in \Sigma \\
    \Sclosed{\lab{D}}{\vec{\lab{C}}} \in \Sigma \\
    \Sigma \mid T : (\vec{x} : \Crepr{\Delta}) \to A[\vec{x}] \to \univ_0 ,\
    \vec{a} : \Crepr{\Delta}  ,\
    \eta : A[\vec{a}]  ,\
    \left( m_i : (\vec{y} : \Crepr{\Delta_{\lab{C}_i}}) \to (\Id{A[\vec{a}]}{\eta}{\pi_1 t_i[\vec{a},\vec{y}]}) \to {T(\vec{a}, \pi_1 t_i[\vec{a}, \vec{y}])} \mid i \in I \right)
    \vdash e : T(\vec{a}, \eta)
    }
    {\Sigma \vdash \Srepr{R}{\caselab{D}}{T\,\vec{a}\,\eta\,\vec{m}}{e}} \and
    \inferrule[Repr-Fun]
    {
      \Sfun{f}{M}{m} \in \Sigma     \\
      % \isLabNotIn{R}{\Sigma} \\
      \Sigma \vdash a : (m' : \Crepr{M}) \times (\Id{\Crepr{M}}{\crepr{m}}{m'})
    }
    {\Sigma \vdash \Sreprconst{R}{f}{a}}
  \end{mathpar}
  \caption{Typing rules for data representations in $\lambdarep$.}
  \label{fig:lambdarep-rules}
\end{figure}

The correctness of a representation of some data type $\lab{D}$ is ensured by
the correctness of the representations of each of its constructors $\lab{C}_i$
and the case analysis function $\caselab{D}$. Therefore there is no special
correctness condition for the data representation type itself. The constructor
representations $\Sreprvar{R}{\lab{C}_i}{\Crepr{\Delta_{\lab{C}_i}}}{t_i}$ form
an \emph{algebra} over the endofunctor $\llbracket \lab{D} \rrbracket$
associated with the data type $\lab{D}$, by packaging all the representation
values $\pi_1 t_i$, where the carrier object is the defined representation type
$A$. Moreover, this algebra is \emph{injective} in the sense that the
representation values are unique for each constructor, ensured by the equality
constraints $\pi_1 t_i \neq \pi_1 t_j$ for $i \neq j$.

It is known that algebras over indexed inductive types can be interpreted as
\emph{ornaments} \cite{Dagand2017-nj}; an inductive type is decorated with the
values of the algebra at each node. We can apply the constructor representation
algebra $(t_i \mid i \in I)$ to the inductive type $\lab{D}$ to obtain the
ornamented type $\tilde{\lab{D}}$. The case analysis $\caselab{D}$
representation is thus a \emph{section} of $\tilde{\lab{D}}$ by the represented
type $A$. In other words, it must ensure that the subject $\eta$ of the case
analysis is used to index into the ornamented type $\tilde{\lab{D}}$, or put
another way, that the propositional equality $\eta = \pi_1 t_i$ holds when the
branch $m_i$ is invoked. Overall, this yields an isomorphism between the
inductive type $\lab{D}$ and the represented type $A$, in the Kleisli category
of the code-generation monad of the object-level language (TODO: expand on
this!).

In \cref{fig:lambdarep-rules}, the symbols $\Crepr{}$ and $\crepr{}$
\emph{lower} the given atoms from the meta level to the object level, through
the defined representations in $\Sigma$. To define them, we need to introduce a
concept of \emph{concrete signatures}. A concrete signature is a signature
where all items are accompanied by representations. In other words, $\Sigma$ is
a concrete signature
\begin{itemize}
  \item if $\Sdata{D}{\Delta} \in \Sigma$, then $\exists A \, \widehat{\Delta} .\
          \Srepr{R}{D}{\widehat{\Delta}}{A} \in \Sigma$,
  \item if $\Sctorvar{\lab{C}}{\Delta_{\lab{C}}}{D}{\Delta} \in \Sigma$, then $\exists
          t\,\widehat{\Delta_\lab{C}} .\
          \Sreprvar{R}{\lab{C}}{\widehat{\Delta_{\lab{C}}}}{t} \in \Sigma$,
  \item if $\Sclosed{\lab{D}}{\vec{\lab{C}}} \in \Sigma$, then $\exists
          T\,\vec{a}\,\eta\,\vec{m} .\ \Srepr{R}{\caselab{D}}{T\,\vec{a}\,\eta\,\vec{m}
          }{e} \in \Sigma$, and
  \item if $\Sfun{f}{M}{m} \in \Sigma$, then $\exists a .\ \Sreprconst{R}{f}{a} \in
          \Sigma$.
\end{itemize}
We can now define the lowering functions $\Crepr{}$ and $\crepr{}$ as follows:
\begin{align*}
  \Crepr{}
\end{align*}
