\section{A type system for data representations}\label{sec:type-system}

In this section, we describe a type system for data representations in a
language with dependent types. We start by defining a core language with
dependent types and inductive constructions $\lambdaind$. We then extend this
language with data representations to form $\lambdarep$, which allow users to
define custom representations for inductive types and other global symbols.
We present these languages with intrinsically well-formed contexts, types, and
terms, quotiented by their definitional equality rules [altenkirch].

\subsection{A core language with inductive types, $\lambdaind$}\label{sub:lambdaind}

The core languge we start with is $\lambdaind$. It contains $\Pi$-types and a
single universe $\univ$ with $\univ : \univ$. We are not concerned with universe
polymorphism or a sound logical interpretation as this is orthogonal to the main
focus of this work. Nevertheless, all the results should be readily extensible
to a sound language with a universe hierarchy.
We follow a similar approach to
\cite{Cockx2018-fk} by packaging named inductive constructions and
global function definitions into a signature, and indexing contexts by
signatures. A typing judgement looks like
\[
  \Sigma \mid \Gamma \vdash t : T
\]
and is read as ``in signature $\Sigma$ and context $\Gamma$, term $t$ has type
$T$''. The rules for signatures, contexts and telescopes are given in \cref{fig:lambdaind-sig-rules}.

\begin{figure}[h]
  \begin{mathpar}
    \inferrule[Sig-Empty]
    {
    }
    {\isSig{\cdot}} \and
    \inferrule[Sig-Extend]
    {
      \isSig{\Sigma} \\
      \Sigma \vdash Z
    }
    {\isSig{\Sigma,Z}} \and
    \inferrule[Con-Empty]
    {
      \isSig{\Sigma}
    }
    {\Sigma \vdash \isCon{\cdot}} \and
    \inferrule[Con-Extend]
    {
      \Sigma \vdash \isCon{\Gamma} \\
      \Sigma \mid \Gamma \vdash \istype{T}
    }
    {\Sigma \vdash \isCon{\Gamma,T}} \and
    \inferrule[Tel-Empty]
    {
      \Sigma \vdash \isCon{\Gamma}
    }
    {\Sigma \mid \Gamma \vdash \isTel{\cdot}} \and
    \inferrule[Tel-Extend]
    {
      \Sigma \mid \Gamma \vdash \isTel{\Delta} \and
      \Sigma \mid \Gamma \vdash \istype{T}
    }
    {\Sigma \mid \Gamma \vdash \isTel{\Gamma,T}}
  \end{mathpar}
  \caption{Rules for signatures, contexts and telescopes in $\lambdaind$.}
  \label{fig:lambdaind-sig-rules}
\end{figure}

Telescopes [deBrujin] are very similar to contexts, but restricted to types from a single stage and
well formed with respect to a context $\Gamma$, meaning that telescopes can
contain open terms. We use the notation $\Delta \to t$ to denote a repeated
function type with parameters from $\Delta$ and codomain $T$ which may depend
on the parameters. Additionally, we will sometimes explicitly bind the names of
a telescope such as $(\delta : \Delta) \to T[\delta]$. Similar syntax is used
to extend contexts with telescopes: $\Gamma, \Delta$ or $\Gamma, \delta :
  \Delta$.

Next, the rules for well-formed items in signatures are given in
\cref{fig:lambdaind-item-rules}. \todo{Awkward spacing!}

\begin{figure}[h]
  \begin{mathpar}
    \inferrule[Data-Item]
    {
      \Sigma \mid \cdot \vdash \isTel{\Delta} \\
      \Sigma \mid \Delta \vdash \isTel{\Xi} \\
      \isLabNotIn{D}{\Sigma} \\
    }
    {\Sigma \vdash \Sdata{D}{\Delta}{\Xi}} \and
    \inferrule[Ctor-Item]
    {
      \Sdata{D}{\Delta}{\Xi} \in \Sigma \\
      \Sclosed{\lab{D}, \wildp} \notin \Sigma \\
      \isLabNotIn{C}{\Sigma} \\
      \Sigma \mid \Delta \vdash \isTel{\Pi} \\
      \Sigma \mid \Delta, \Pi \vdash \isTel{\Omega} \\
      \Sigma \mid \Delta, \Pi \vdash \xi : \Xi
    }
    {\Sigma \vdash \Sctor{C}{\Pi\ \Omega}{D}{\Delta\ \xi}} \and
    \inferrule[Closed-Item]
    {
      \Sdata{D}{\Delta}{\Xi} \in \Sigma \\
      \forall i \in I. \ \Sctorvar{\lab{C}_i}{\Pi_i}{D}{\Delta\ \xi_i} \in \Sigma \\
      \Sclosed{\lab{D}, \wildp} \notin \Sigma
    }
    {\Sigma \vdash \Sclosed{\lab{D}, \vec{\lab{C}}}} \and
    \inferrule[Def-Type]
    {
      \Sigma \mid \cdot \vdash M : \univ \\
      \isLabNotIn{f}{\Sigma}
    }
    {\Sigma \vdash \Sdef{f}{M}{m}} \and
    \inferrule[Def-Item]
    {
      \Sigma, \Sdef{f}{M}{} \mid \cdot \vdash m : M \\
      \isLabNotIn{f}{\Sigma}
    }
    {\Sigma \vdash \Sdef{f}{M}{m}}
  \end{mathpar}
  \caption{Rules for items in signatures in $\lambdaind$.}
  \label{fig:lambdaind-item-rules}
\end{figure}

\begin{figure}[H]
  \begin{mathpar}
    \inferrule[Data-Form]
    {
      \Sdata{D}{\Delta}{\Xi} \in \Sigma
    }
    {\Sigma \mid \Gamma \vdash \datalab{D} : \Delta \to \Xi \to \univ} \and
    \inferrule[Data-Intro]
    {
      \Sdata{D}{\Delta}{\Xi} \in \Sigma     \\
      \Sctor{C}{\Pi}{D}{\Delta\ \xi} \in \Sigma
    }
    {\Sigma \mid \Gamma \vdash \ctorlab{C} : (\delta : \Delta) \to (\pi : \Pi [\delta]) \to \datalab{D} \  \delta \  (\xi [\delta, \pi]) } \and
    \inferrule[Data-Case]
    {
      \Sdata{D}{\Delta}{\Xi} \in \Sigma     \\
      \forall i \in I.\ \Sctorvar{\ctorlab{C}_i}{\Pi_i}{D}{\xi_i} \in \Sigma     \\
      \Sclosed{\datalab D}{\vec{\ctorlab{C}}} \in \Sigma
    }
    {\Sigma \mid \Gamma \vdash \caselab{D} : (\delta : \Delta) \to \mta{Case}((\xi : \Xi[\delta],x : \datalab{D} \  \delta \  \xi), \{ (\pi : \Pi_i [\delta]), (\xi_i [\delta], \ctorlab{C}_i \  \delta \  \pi) \}_i ) } \and
    \inferrule[Data-Case-ID$_j$]
    {
      \Sdata{D}{\Delta}{\Xi} \in \Sigma     \\
      \forall i \in I.\ \Sctorvar{\ctorlab{C}_i}{\Pi_i}{\datalab D}{\xi_i} \in \Sigma     \\
      \Sclosed{\datalab D}{\vec{\ctorlab{C}}} \in \Sigma \\
      \Sigma \mid \Gamma \vdash \delta : \Delta
    }
    {\Sigma \mid \Gamma \vdash \mta{ValidCase}(\caselab{D}\ \delta)} \and
    \inferrule[Def-Intro]
    {
      \Sdef{f}{M}{} \in \Sigma      \\
    }
    {\Sigma \mid \Gamma \vdash \lab{f} : M} \and
    \inferrule[Def-Comp]
    {
      \Sdef{f}{M}{m} \in \Sigma     \\
    }
    {\Sigma \mid \Gamma \vdash \lab{f} \equiv m : M}
  \end{mathpar}
  \caption{Terms and types associated to items in signatures in $\lambdaind$.}
  \label{fig:lambdaind-rules}
\end{figure}

The rules for data constructors do not consider the recursive occurences of $\lab{D}$ explicitly, which means
that strict positivity is not ensured. Rather, we assume that a separate check is performed to ensure that
the defined types adhere to strict positivity, if necessary. As a result, the eliminator for data types does
not provide the inductive hypotheses directly, but we assume that the language allows general recursion. Similarly to
the positivity requirements, we expect that if termination is a desirable property of the system, it is ensured separately
to the provided typing rules.

In \cref{fig:lambdaind-rules}, the type $\Sigma \mid \Gamma \vdash \mta{Case}(\Phi, \{\Pi_k, \phi_k\}_k) : \univ$ is defined as
\begin{mathpar}
  \inferrule
  {
    \Sigma \mid \Gamma \vdash \isTel{\Phi} \\
    \forall k \in K .\ {\Sigma \mid \Gamma \vdash \isTel{\Pi_k}} \\
    \forall k \in K .\ {\Sigma \mid \Gamma, \Pi_k \vdash \phi_k : \Phi}
  }
  {{\mta{Case}(\Phi, \{\Pi_k, \phi_k\}_k) := (P : \Phi \to \univ) \to \{ (\Pi_k \to P \  \phi_k) \}_k \to (\phi : \Phi) \to P \phi}}
\end{mathpar}

The $\Sigma \mid \Gamma \vdash \mta{ValidCase}(c)$ condition is defined inductively as
\begin{mathpar}
  \inferrule
  {
      \Sigma \mid \Gamma \vdash c : \mta{Case}(\Phi, \{\Pi_k, \phi_k\}_k) \\
     {\begin{aligned}
      \forall j \in K . \ \Sigma &\mid \Gamma,  P : \Phi \to \univ, \{\kappa_k : \Pi_k \to P \  \phi_k\}_k, \pi : \Pi_j \\[-0.5em]
      &\vdash c \  P \  \{\kappa_k\}_k \  \phi_j [\pi] \equiv \kappa_j \  \pi : P \  \phi_j[\pi]
    \end{aligned}}
  }
  {\Sigma \mid \Gamma \vdash \mta{ValidCase}(c)}
\end{mathpar}


\subsection{Extending $\lambdaind$ with data representations}\label{sub:lambdarep}

We extend the language $\lambdaind$ to form $\lambdarep$, which allows users to define
custom representations for inductive types and global functions. This language is extended
with a modal type former
\[
  \Repr{} : \Ty\ \Sigma\ \Gamma \to \Ty\ \Sigma\ \Gamma
\]
along with an isomorphism
\[
  \repr{} : \Tm\ \Sigma\ \Gamma\ T \simeq \Tm\ \Sigma\ \Gamma\ (\Repr T) : \unrepr{} \,.
\]

The type $\Repr T$ is the defined representation of the type $T$. The term $\repr{}$ takes
a term of type $T$ to its representation of type $\Repr T$, and $\unrepr{}$ undoes the effect of
$\repr{}$, treating a represented term as an inhabitant of its original type.
These new constructs satisfy certain \emph{homogenous} definitional equalities.
\begin{figure}[h]
    \begin{align*}
      &\Repr{(\Pi\ A\ B)} \equiv \Pi\ A\ (\Repr B) \\
      &\Repr{\univ} \equiv \univ \\
      &\Repr{(A [u])} \equiv (\Repr A) [u]
    \end{align*}
  \begin{minipage}[t]{0.5\textwidth}
    \begin{align*}
      &\repr{(\lambda\ t)} \equiv \lambda\ (\repr{t}) \\
      &\repr{(\ap t)} \equiv \ap{(\repr t)} \\
      &\repr{(t [u])} \equiv (\repr t)[u] \\
      &\repr{(\code t)} \equiv \code t \\
    \end{align*}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.5\textwidth}
    \begin{align*}
      &\unrepr{(\lambda\ t)} \equiv \lambda\ (\unrepr{t}) \\
      &\unrepr{(\ap t)} \equiv \ap{(\unrepr t)} \\
      &\unrepr{(t [u])} \equiv (\unrepr t)[u] \\
      &\unrepr{(\code t)} \equiv \code t
    \end{align*}
  \end{minipage}
  \caption{Basic definitional equalities for $\Repr{}$, $\repr{}$ and
  $\unrepr{}$, omitting the ones that hold by the afforementioned
  isomorphism. Notably $\Repr (\El t)$, as well as $\repr x$ where $x$ is a
  variable, do not reduce.}
  \label{fig:translation}
\end{figure}

\begin{figure}[h]
  \begin{mathpar}
  \inferrule[Repr-Def-Id]
  {
    \Sreprvar{\lab f\ \Delta}{a} \in \Sigma
  }
  {\Sigma \mid \Gamma \vdash \repr{(\lab{f}\ \delta)} \equiv a [\delta] : M[\delta]} \and
  \inferrule[Repr-Ctor-Id]
  {
    \Sreprvar{\ctorlab c\ \Pi}{\kappa} \in \Sigma
  }
  {\Sigma \mid \Gamma \vdash \repr{(\ctorlab{c}\ \delta\ \pi)} \equiv \kappa [\delta, \pi] : A[\delta, \xi[\pi]]} \and
  \inferrule[Repr-Data-Id]
  {
    \Sreprvar{\datalab D\ \Delta\ \Xi}{A} \in \Sigma
  }
  {\Sigma \mid \Gamma \vdash \istype{\Repr{(\datalab{D}\ \delta\ \psi)} \equiv A [\delta,\psi]}} \and
  \inferrule[Repr-Case-Id]
  {
    \Sreprvar{\caselab D}{e} \in \Sigma
  }
  {\Sigma \mid \Gamma \vdash \repr{(\caselab{D}\ \delta)} \equiv e [\delta] : \mta{Case}((\xi : \Xi[\delta],x : A \  \delta \  \xi), \{ (\pi : \Pi_i [\delta]), (\xi_i [\delta], A \  \delta \  \pi) \}_i )} \and
  \end{mathpar}
  \caption{Homogenous definitional equalities for $\Repr{}$ and $\repr{}$.
  Notably $\Repr (\El t)$, as well as $\repr x$ where $x$ is a variable, do not
  reduce.}
  \label{fig:translation}
\end{figure}


\begin{figure}[h]
  \begin{mathpar}
    \inferrule[Repr-Data]
    {
      \Sdata{D}{\Delta}{\Xi} \in \Sigma     \\
      \Sigma \mid \Delta, \Xi \vdash A : \univ \\
    }
    {\Sigma \vdash \Sreprvar{\datalab D\ \Delta\ \Xi}{A}} \and
    \inferrule[Repr-Ctor]
    {
    \Sdata{D}{\Delta}{\Xi} \in \Sigma     \\
    \forall i \in I .\ \Sctorvar{\ctorlab{C}_i}{\Pi_i}{D}{\Delta\ \xi_i} \in \Sigma     \\
    \Sreprvar{\datalab D}{\Delta\ \Xi}{A} \in \Sigma \\
    \forall i < k .\ \Sreprvar{\ctorlab{C}_i}{\Pi_i}{t_i} \in \Sigma     \\
    \Sigma \mid \Delta, \Pi_k \vdash t_k : A \  \Delta \  \xi_k
    % \Sigma \mid \vec{x} : \Crepr{\Delta}, \ \vec{z} : \Crepr{\Delta_{\ctorlab{C}_i}} \vdash t_i : (a : A) \times \textstyle \prod_{j < i} ((\vec{y} : \Crepr{\Delta_{\ctorlab{C}_j}}) \to a \neq \pi_1 t_j[\vec{x},\vec{y}])
    }
    {\Sigma \vdash \Sreprvar{\ctorlab{C}_k\ \Pi_k}{t_k}} \and
    \inferrule[Repr-Case]
    {
    \Sdata{D}{\Delta}{\Xi} \in \Sigma     \\
    \Sreprvar{\datalab D\ \Delta\ \Xi}{A} \in \Sigma \\
    \forall i \in I .\ \Sctorvar{\ctorlab{C}_i}{\Pi_i}{D}{\Delta\ \xi_i} \in \Sigma     \\
    \forall i \in I .\ \Sreprvar{\ctorlab{C}_i}{\Pi_i}{t_i} \in \Sigma     \\
    \Sclosed{\datalab{D}}{\vec{\ctorlab{C}}} \in \Sigma \\
    {\Sigma \mid \delta : \Delta \vdash c : \mta{Case}((\xi : \Xi[\delta],x : A \  \delta \  \xi), \{ (\pi : \Pi_i [\delta]), (\xi_i [\delta], A \  \delta \  \pi) \}_i ) } \\
    \Sigma \mid \Delta \vdash \mta{ValidCase} ( c )
    }
    {\Sigma \vdash \Sreprvar{\caselab{D}}{\Delta}{c}} \and
    \inferrule[Repr-Def]
    {
      \Sdef{f}{M}{m} \in \Sigma     \\
      % \isLabNotIn{R}{\Sigma} \\
      \Sigma \mid \cdot \vdash a : M \\
      \Sigma \mid \cdot \vdash m \equiv a : M
    }
    {\Sigma \vdash \Sreprvar{\lab f}{a}}
  \end{mathpar}
  \caption{Rules for data representations in $\lambdarep$.}
  \label{fig:lambdarep-rules}
\end{figure}

\subsection{Properties of $\lambdarep$}

\begin{itemize}
  \item Decidability of equality
  \item Confluence of reduction
  \item Strong normalization
\end{itemize}

\section{Translating from $\lambdarep$ to $\lambdaind$}

Now we define a translation step $\R$ from $\lambdarep$ to $\lambdaind$. We do this by
translating contexts, substitutions, types, and terms in a mutual manner. The majority
of the translation simply preserves the structure of $\lambdarep$, so we focus on the
translation of inductive types into their representations.

\begin{figure}[h]
  \begin{minipage}[t]{0.45\textwidth}
    \begin{align*}
      &\R : \Ty_{\rep}\ \Sigma\ \Gamma \to \Ty_{\ind}\ (\R \Sigma)\ (\R \Gamma) \\
      &\R (\datalab{D}\ \delta\ \psi) = \R (A[\delta,\psi]) \\
      &\R (\Repr A) = \R A \\
      &\R T = \text{recurse on $T$}
    \end{align*}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.45\textwidth}
    \begin{align*}
      &\R : \Tm_{\rep}\ \Sigma\ \Gamma\ T \to \Tm_{\ind}\ (\R \Sigma)\ (\R \Gamma)\ (\R T) \\
      &\R (\ctorlab{C}\ \delta\ \pi) = \R (t[\delta,\pi]) \\
      &\R (\repr A) = \R A \\
      &\R (\unrepr A) = \R A \\
      &\R t = \text{recurse on $t$}
    \end{align*}
  \end{minipage}
  \caption{Translation from $\lambdarep$ to $\lambdaind$.}
  \label{fig:translation}
\end{figure}


\begin{itemize}
  \item Setoid homomorphism
  \item Faithful translation (setoid injectivity)
  \item Corollaries
\end{itemize}
