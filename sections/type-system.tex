\section{A type system for data representations}\label{sec:type-system}

This section provides an overview of the language $\lambdarep$, which has
dependent types and representations for inductive families and global function
definitions. We start with a core language with inductive families $\lambdaind$,
that is extended with data representations to form $\lambdarep$. All of the
examples in the paper are written in a surface language that elaborates to
$\lambdarep$.

\subsection{The core language, $\lambdaind$}

The languge $\lambdaind$, is a dependent type theory with $\Pi$ and a universe
$\univ$, extended with strictly positive inductive families and global
definitions. The base layer is a standard dependent type theory, defined in an
intrinsically well-formed fashion quotiented by conversion. The constructors of
the syntax are given in \cref{fig:base-formers}. We omit the conversion
equations for brevity as they are standard \cite{Altenkirch2016-zc}.

We will not convern ourselves with universe levels because a sound logical
interpretation is not of much interest in this paper. Nevertheless, all of our
results should be readily adaptable to a calculus with universe levels.

We follow a similar approach to Cockx~and~Abel~\cite{Cockx2018-fk}
by packaging named inductive constructions and global function definitions into
a signature $\Sigma$, and indexing contexts by signatures.

To do this, we define signatures, local contexts, and contexts (as well as terms
and types) by mutual induction.

\newcommand{\ValidCase}{\mta{ValidCase}}

\subsection{Extending $\lambdaind$ with representations}\label{sub:lambdarep}

We extend the language $\lambdaind$ to form $\lambdarep$, which allows users to
define custom representations for inductive types and global functions. First,
we add a type former
\begin{equation}\label{eq:repr-ty}
  \Repr{} : \Ty\ (\Sigma\mid \Gamma) \to \Ty\ (\Sigma\mid \Gamma)
\end{equation}
along with two new terms in the syntax, forming an isomorphism
\begin{equation}\label{eq:repr-iso}
  \repr{} : \Tm\ (\Sigma\mid \Gamma)\ T \simeq \Tm\ (\Sigma\mid \Gamma)\ (\Repr T) : \unrepr{} \,.
\end{equation}
which holds definitionally and preserves $\Pi$ and universes. The type $\Repr T$
is the defined representation of the type $T$. The term $\repr{}$ takes a term
of type $T$ to its representation of type $\Repr T$, and $\unrepr{}$ undoes the
effect of $\repr{}$, treating a represented term as an inhabitant of its
original type. These new constructs satisfy certain equalities, which are
spelled out in . New valid signature items are introduced,
corresponding to representation definitions for components of inductive families
and global function definitions, shown in \cref{fig:global-rep-eq}.

\begin{figure}[h]
  \begin{mathpar}
  \inferrule[Repr-Form]
  {
    \Sigma \mid \Gamma \vdash \istype{T}_i
  }
  {
    \Sigma \mid \Gamma \vdash \istype{\Repr{T}}_i
  } \and
  \inferrule[Repr-Intro]
  {
    \Sigma \mid \Gamma \vdash t : T
  }
  {
    \Sigma \mid \Gamma \vdash \repr{t} : \Repr{T}
  } \and
  \inferrule[Repr-Elim]
  {
    \Sigma \mid \Gamma \vdash u : \Repr{T}
  }
  {
    \Sigma \mid \Gamma \vdash \unrepr{u} : T
  } \and
  \inferrule[Repr-Unrepr-Id]
  {
    \Sigma \mid \Gamma \vdash u : \Repr{T}
  }
  {
    \Sigma \mid \Gamma \vdash \repr{(\unrepr{u})} \equiv u : \Repr{T}
  } \and
  \inferrule[Unrepr-Repr-Id]
  {
    \Sigma \mid \Gamma \vdash t : T
  }
  {
    \Sigma \mid \Gamma \vdash \unrepr{(\repr{t})} \equiv t : T
  } \and
  \inferrule[Repr-Type-Subst-Id]
  {
    \Sigma \mid \Gamma \vdash \istype{T}_i \\
    \Sigma \mid \Delta \vdash \sigma : \Gamma
  }
  {
    \Sigma \mid \Delta \vdash \Repr{(T[\sigma])} \equiv (\Repr{T})[\sigma]
  } \and
  \inferrule[Repr-Term-Subst-Id]
  {
    \Sigma \mid \Gamma \vdash t : T \\
    \Sigma \mid \Delta \vdash \sigma : \Gamma
  }
  {
    \Sigma \mid \Delta \vdash \repr{(t[\sigma])} \equiv (\repr{t})[\sigma] : \Repr{(T[\sigma])}
  } \and
  \inferrule[Unrepr-Term-Subst-Id]
  {
    \Sigma \mid \Gamma \vdash t : \Repr T \\
    \Sigma \mid \Delta \vdash \sigma : \Gamma
  }
  {
    \Sigma \mid \Delta \vdash \unrepr{(t[\sigma])} \equiv (\unrepr{t})[\sigma] : T[\sigma]
  }
  \end{mathpar}
  \caption{New term and type formers, and accompanying definitional equalities in $\lambdarep$.}
  \label{fig:repr-rules}
\end{figure}

\begin{figure}[h]
  \begin{mathpar}
  \inferrule[Repr-$\Pi$-Id]
  {
    \Sigma \mid \Gamma \vdash \istype{T}_i \\
    \Sigma \mid \Gamma,T \vdash \istype{U}_i
  }
  {
    \Sigma \mid \Gamma \vdash \Repr{(\Pi\ T\ U)} \equiv \Pi\ T\ (\Repr{U})
  }\and
  \inferrule[Repr-$\lambda$-Id]
  {
    \Sigma \mid \Gamma, T \vdash u : U
  }
  {
    \Sigma \mid \Gamma \vdash \repr{(\lambda\ u)} \equiv \lambda\ (\repr{u}) : \Repr{(\Pi\ T\ U)}
  } \and
  \inferrule[Unepr-$\lambda$-Id]
  {
    \Sigma \mid \Gamma, T \vdash u : \Repr U
  }
  {
    \Sigma \mid \Gamma \vdash \unrepr{(\lambda\ u)} \equiv \lambda\ (\unrepr{u}) : \Pi\ T\ U
  } \and
  \inferrule[Repr-App-Id]
  {
    \Sigma \mid \Gamma \vdash f : \Pi\ T\ U \\
    \Sigma \mid \Gamma \vdash t : T
  }
  {
    \Sigma \mid \Gamma \vdash \repr{(f\ t)} \equiv (\repr{f})\ t : \Repr{U}
  } \and
  \inferrule[Unrepr-App-Id]
  {
    \Sigma \mid \Gamma \vdash f : \Repr{(\Pi\ T\ U)} \\
    \Sigma \mid \Gamma \vdash t : T
  }
  {
    \Sigma \mid \Gamma \vdash \unrepr{(f\ t)} \equiv (\unrepr{f})\ t : U
  }
  \end{mathpar}
  \caption{Coherence of representation terms with $\Pi$-types.}
  \label{fig:repr-pi-rules}
\end{figure}

\begin{figure}[h]
  \begin{mathpar}
  \inferrule[Repr-$\univ_i$-Id]
  { }
  {
    \Sigma \mid \Gamma \vdash \Repr{\univ_i} \equiv \univ_i 
  } \and
  \inferrule[Repr-Code-Id]
  {
    \Sigma \mid \Gamma \vdash \istype{T}_i
  }
  {
    \Sigma \mid \Gamma \vdash \repr{(\Code{T})} \equiv \Code{T} : \univ_i
  } \and
  \inferrule[Unrepr-Code-Id]
  {
    \Sigma \mid \Gamma \vdash \istype{T}_i
  }
  {
    \Sigma \mid \Gamma \vdash \unrepr{(\Code{T})} \equiv \Code{T} : \univ_i
  }
  \end{mathpar}
  \caption{Coherence of representation terms with universes.}
  \label{fig:repr-univ-rules}
\end{figure}

\begin{figure}[h]
  \begin{mathpar}
  \inferrule[Repr-Ctor-Id]
  {
    \Sreprvar{\ctorlab c\ \Pi}{\kappa} \in \Sigma
  }
  {\Sigma \mid \Gamma \vdash \repr{(\ctorlab{c}\ \delta\ \pi)} \equiv \kappa [\delta, \pi] : A[\delta, \xi[\pi]]} \and
  \inferrule[Repr-Data-Id]
  {
    \Sreprvar{\datalab D\ \Delta\ \Xi}{A} \in \Sigma
  }
  {\Sigma \mid \Gamma \vdash \istype{\Repr{(\datalab{D}\ \delta\ \psi)} \equiv A [\delta,\psi]}}
  \end{mathpar}
  \caption{Definitional equalities for $\Repr{}$ and $\repr{}$ relating to data
  types and constructors with defined representations. Similar equalities hold
  for representations of global function definitions and eliminators, albeit
  propositionally.}
  \label{fig:global-rep-eq}
\end{figure}

We state some basic lemmas below. The proof are left to the full version
of the paper, along with the formalisation of computational irrelevance.

\begin{lemma}
  The term formers $\repr{}$ and $\unrepr{}$ are injective, i.e.
  \begin{mathpar}
    \inferrule
    {
      \Sigma \mid \Gamma \vdash \repr{t} \equiv \repr{t'} : \Repr T
    }
    {
      \Sigma \mid \Gamma \vdash t \equiv t' : T
    } \and
    \inferrule
    {
      \Sigma \mid \Gamma \vdash \unrepr{t} \equiv \unrepr{t'} : T
    }
    {
      \Sigma \mid \Gamma \vdash t \equiv t' : \Repr T
    }
  \end{mathpar}
\end{lemma}

\begin{lemma}
  The type former $\Repr{}$ is injective up to internal isomorphism, i.e.
  \begin{mathpar}
    \inferrule
    {
      \Sigma \mid \Gamma \vdash \istype{\Repr T \equiv \Repr T'}
    }
    {
      \Sigma \mid \Gamma \vdash p : T\ \datalab{$\simeq$}\ T'
    }
  \end{mathpar}
  Moreover, this isomorphism is computationally irrelevant.
\end{lemma}

\section{Translating from $\lambdarep$ to $\lambdaind$}

We can define a translation step $\R$ from $\lambdarep$ to
$\lambdaind^{\textsc{Ext}}$, meant to be applied during the compilation process.
More specifically, the translation target is the extensional flavour of
$\lambdaind$ by adding the equality reflection rule. We do this by translating
well-formed contexts, substitutions, types, and terms in a mutual manner such
that definitional equality is preserved. $\R$ preserves the structure of
$\lambdarep$, but maps constructs to their terminal representations. Eliminator
coherence rules are preserved by reflecting the propositional coherence rules
provided by the defined representations. We will prove some desired properties
of $\R$ \cite{Boulier2017-cm} such as typing and computational soundness, and
preservation of consistency. The final program can then be converted into a
simply-typed language which erases irrelevant data. We can recover a program in
$\lambdaind$ by translating extensional typing derivations to intensional proofs
\cite{Winterhalter2019-zw}.
