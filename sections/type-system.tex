\section{A type system for data representations}\label{sec:type-system}


In this section, we will develop an extension of dependent type theory with
inductive families and custom data representations. We start in
\cref{sub:algebras} by exploring the semantics of data representations in terms
of algebras for signatures. In \cref{sub:lambdaind}
we define a core language with inductive families $\lambdaind$. In
\cref{sub:lambdarep}, we extend this language with data representations to form
$\lambdarep$. All of the examples in the paper are written in a surface language
that elaborates to $\lambdarep$.

We work in an extensional metatheory with a small universe $\Set$, $(a : A)
\times B$ for dependent pairs, $(a : A) \to B$ for dependent products, and $=$
for equality. The metatheory also supports quotient-inductive-inductive
definitions, which are used to define the syntaxes of the languages presented in
this paper in the style of Kaposi and Altenkirch~\cite{Altenkirch2016-zc}.
Weakening of terms is generally also left implicit to reduce syntactic noise,
and sometimes higher-order abstract syntax notation is used for the
languages defined.

\newcommand{\ValidCase}{\mta{ValidCase}}

\subsection{Algebras, displayed algebras and inductive algebras} \label{sub:algebras}

A representation of a data type must be able to emulate the behaviour of the
original data type. In turn, the behaviour of the original data type is
determined by its elimination, or induction principle. This means that a
representation of a data type should provide an implementation of induction of
the same `shape' as the original. Induction can be characterised in terms of
algebras and displayed algebras of algebraic signatures.

Algebraic signatures consist of a list of operations, each with a specified
arity. There are many flavours of algebraic signatures with varying degrees of
expressiveness. For this paper, we are interested in algebraic signatures which can
be used as a syntax for defining inductive families in a type theory. Thus, we define
\begin{align*}
    &\mta{Theory} : (\Gamma : \Con) \to \mta{Tel}\ \Gamma \to \Set \\
    &\bullet : \mta{Theory}\ \Gamma\ P \\
    &\rhd : (T : \mta{Theory}\ P) \to \mta{Op}\ P \to \mta{Theory}\ P \\[1em]
    &\mta{Op} : (\Gamma : \Con) \to \mta{Tel}\ \Gamma \to \Set \\
    &\Pi : (A : \Ty\ \Gamma) \to \mta{Op}\ (\Gamma \rhd A)\ P \to \mta{Op}\ \Gamma\ P \\
    &\Pi\iota : (p : \Tms\ \Gamma\ P) \to \mta{Op}\ \Gamma\ P \to \mta{Op}\ \Gamma\ P \\
    &\iota : (p : \Tms\ \Gamma\ P) \to \mta{Op}\ \Gamma\ P
\end{align*}
The $\mta{Theory}$ sort represents a simple class of algebraic signatures. We do
not call it $\mta{Signature}$ to avoid a name clash with another kind of `signatures'
that we will define later. Indeed, algebraic theories are a generalization of
algebraic signatures. Each theory has an associated telescope of parameters $P$
picked from some external type theory (not the metatheory), and contains a list of operations:
\begin{itemize}
    \item $\Pi\ A\ B$, a (dependent) abstraction over some type $A$ from the
    external type theory, of another operation $B$. \item $\Pi\iota\ p\ B$, an
    abstraction over a recursive occurence of
    the object being defined, with parameters $p$, of another operation
    $B$.
    \item $\iota\ p$, a constructor of the object being defined, with parameters $p$.
\end{itemize}
For example, the theory of natural numbers lives in the empty context has an
empty telescope of parameters. It is defined by
\begin{align*}
	&\mta{NatTh} : \mta{Theory}\ \bullet\ \bullet \\
	&\mta{NatTh} := \bullet \rhd \iota\ (\,) \rhd \Pi\iota\ (\,)\ (\iota\ (\,))
\end{align*}
We can add labels to aid readability, omitting parameters
if they are empty, and use $\Rightarrow$ for simple arrows:
\[
\mta{NatTh} := \bullet \rhd \textit{zero} : \iota \rhd \textit{succ} : \iota \Rightarrow \iota
\]
Notice that this syntax only allows occurrences of $\iota$ in positive
positions, which is a requirement for inductive types.
We could also add other constructors for operations. For example, we allow
external quantification in some other type theory, but we could also allow quantification
on the level of the \emph{metatheory} (ignoring size issues) by an operation
\[
\Pi_{\mta{meta}} : (A : \Set) \to (A \to \mta{Op}\ \Gamma\ P) \to \mta{Op}\ \Gamma\ P
\]
We do not require this kind of abstraction for this paper but different classes of
theories and quantification are explored in detail by Kov\'acs \cite{Kovacs2023-gq}.

In order to make use of our definition for theories, we would like to be able to interpret
the structure into a semantic universe. An algebra $(X, a) : \mta{Alg}\ T$
for a carrier $X$ and theory $T$ defines a way to interpret the structure of $T$
in terms of a type in a type theory $X : \mta{Ty}\ \Gamma$. This produces a type which
matches the structure of $T$ but replaces each occurrence of $\iota$ with $X$.
The function arrows in $T$ are interpreted as function arrows in the target universe.
Algebras for the theory of natural numbers might look like
\[
	\mta{Alg}\ \mta{NatTh}\simeq (X : \Ty\ \Gamma) \times (\textit{zero} : \Tm\ \Gamma\ X) \times (\textit{succ} : \Tm\ \Gamma\ (\Pi\ X\ X))
\]
We have a choice in terms of how much we want to interpret $T$ in the external type theory,
and how much we want to interpret it in the \emph{metatheory}. Here we have chosen to interpret
a theory as a metatheoretical iterated pair type, but an operation as a term in the type theory.

Very special classes of algebras support \emph{induction}.
To formulate induction, we first need to define displayed algebras.
A displayed algebra $(M, m)$ over an algebra $(X, a)$ for a theory $T$ with
carrier $M$ mirrors the shape of $T$ like an algebra does, but each recursive
occurrence $\iota$ is now replaced by $M$ applied to the corresponding value of
the algebra. The displayed algebras for natural numbers are
\begin{align*}
	\mta{DispAlg}\ (X, \textit{zero}, \textit{succ}) & \simeq (M : \Ty\ (\Gamma \rhd X))                                                      \\
	                               & \quad \times (\textit{zero'} : \Tm\ \Gamma\ M[\textit{zero}])                                            \\
	                               & \quad \times (\textit{succ'} : \Tm\ \Gamma\ (\Pi\ (x : X)\ (\Pi\ M[x]\ M[\mta{app}\ \textit{succ}\ x])))
\end{align*}
The type $M$ is often called the \emph{motive}, and $m$ the \emph{methods}.

\begin{definition}
An algebra is \emph{inductive} if every displayed algebra over it has a section.
\end{definition}
A section is a dependent function from $X$ to $M$ which takes its values from
the displayed algebra. For natural numebrs,
\begin{align*}
	\mta{Section}\  & \{(X, \textit{zero}, \textit{succ})\}\ (M, \textit{zero'}, \textit{succ'})                                                                                           \\
	                & \simeq (f : \Tm\ \Gamma\ (\Pi\ (x : X)\ M[x]))                                                                                   \\
	                & \quad \times (\mta{app}\ f\ \textit{zero} = \textit{zero'})                                                                                        \\
	                & \quad \times ((x : \Tm\ \Gamma\ X) \to \mta{app}\ f\ (\mta{app}\ \textit{succ}\ x) = \mta{app}\ (\mta{app}\ \textit{succ'}\ x)\ (\mta{app}\ f\ x))
\end{align*}
A section is the output of induction: a proof of $M$ for all $X$.

\subsection{Internal and external constructions}

For the remainder of the paper we choose a fixed representation for algebras,
displayed algebras and sections. We will omit the full definitions here for
space, but they can be found in \cref{app:algebras} of the appendix.

We define these constructions in two ways: one that is fully internal to the
type theory and the other that is partially external (using the metatheory).
In particular, all the external constructions are \emph{positive} in the
syntax of the type theory (\mta{Ty}, \mta{Tm}, \mta{Tel}, etc) so that
they can be added into the syntax retroactively.

First, we define an `external' version of algebras
\begin{align*}
    &\mta{Alg}\ T := (X : \Ty\ \Gamma) \times \mta{Algebra}\ T\ X \\
    &\mta{Algebra}\ T\ X := (a : \mta{Args}\ T\ X) \to \Tm\ \Gamma\ X[\Msub{\mta{out}\ a}] \,.
\end{align*}
which take some arguments $\mta{Args}$ and produce the output $X$
evaluated at the appropriate index $\mta{out}\ a$ based on the arguments. The
type $\mta{Args}$ is defined as $(v : \mta{Var}\ T) \times \Tms\ \Gamma\
(\mta{argsFor}\ (T\ v)\ X)$ for the obvious type $\mta{Var}\ T$ which indexes
operations in theories, where
\begin{align*}
    &\mta{argsFor} : \mta{Op}\ \Gamma\ P \to \Ty\ \Gamma \to \Tel\ \Gamma \\
    &\mta{argsFor}\ (\Pi\ A\ B)\ X := \bullet \rhd (a : A) \rhd \mta{argsFor}\ B[\Msub a]\ X \\
    &\mta{argsFor}\ (\Pi\iota\ p\ B)\ X := \bullet \rhd X[\Msub p] \rhd \mta{argsFor}\ B\ X \\
    &\mta{argsFor}\ (\iota\ p)\ X := \bullet
\end{align*}
and $\mta{out}$ is defined as $\mta{outFor}\ \{T\ v\}\ a\ X$ where
\begin{align*}
    &\mta{outFor} : \{O : \Op\ \Gamma\ P\} \to \Tms\ \Gamma\ (\mta{argsFor}\ O\ X) \to \Ty\ \Gamma \to \Tms\ \Gamma\ P \\
    &\mta{outFor}\ \{\Pi\ A\ B\}\ (a, t)\ X := \mta{outFor}\ \{B[\Msub a]\}\ t\ X \\
    &\mta{outFor}\ \{\Pi\iota\ p\ B\}\ (r, t)\ X := \mta{outFor}\ \{B\}\ t\ X \\
    &\mta{outFor}\ \{\iota\ p\}\ (\,)\ X := p \,.
\end{align*}
We can also define a fully-internal version of algebras $\mta{algebra}\ T\ X$ as $\mta{Var}\ T$-indexed telescopes of
\begin{align*}
    &\mta{algebraFor} : \mta{Op}\ \Gamma\ P \to \Ty\ \Gamma \to \Ty\ \Gamma \\
    &\mta{algebraFor}\ (\Pi\ A\ B)\ X := \Pi\ (a : A)\ (\mta{algebraFor}\ B[\Msub a]\ X) \\
    &\mta{algebraFor}\ (\Pi\iota\ p\ B)\ X := \Pi\ X[\Msub p]\ (\mta{algebraFor}\ B\ X) \\
    &\mta{algebraFor}\ (\iota\ p)\ X := X[\Msub p] \,.
\end{align*}
which have evident `realisation' functions into the metatheory
\begin{align*}
    &\emb{\_} : \Tms\ \Gamma\ (\mta{alg}\ T) \to \mta{Alg}\ T \\
    &\emb{\_} : \Tms\ \Gamma\ (\mta{algebra}\ T\ X) \to \mta{Algebra}\ T\ X \,.
\end{align*}

% We can similarly define internal displayed algebras over external algebras $(X,
% x) : \mta{Alg}\ T$ as
% \begin{align*}
%     &\mta{dispAlgebra}\ (X, x) : \Tel\ (\Gamma \rhd M : \Ty\ (\Gamma \rhd P \rhd X)) \\
%     &\mta{dispAlg}\ (X, x) := \bullet \rhd M : \Ty\ (\Gamma \rhd P \rhd X) \rhd \mta{dispAlgebra}\ (X, x)
% \end{align*}
% and finally sections as
% \begin{align*}
%     &\mta{Sec}\ M := \Tm\ (\Gamma \rhd P \rhd X)\ M \\
%     &\mta{Coh}\ f := \forall a. f[\Msub{\mta{out}\ a; x\ a}] = m\ (\mta{disp}\ f\ a) \\
%     &\mta{Section}\ (M, m) := (f : \mta{Sec}\ M) \times \mta{Coh}\ f
% \end{align*}

A similar construction can be performed for displayed algebras over external algebras
\begin{align*}
&\mta{dispAlgebra}\ (X, x)\ M : \Tel\ \Gamma \\
&\mta{DispAlg}\ (X, x) := (M : \mta{Ty}\ (\Gamma \rhd P \rhd X)) \times \mta{Tms}\ \Gamma\ (\mta{dispAlgebra}\ (X, x)\ M)
\end{align*}
and we can use the realisation function for algebras to get internal displayed
algebras over internal algebras
\begin{align*}
    &\mta{dispAlg} : \Tel\ (\Gamma \rhd \mta{alg}\ T) \\
    &\mta{dispAlg} := a.\ \bullet \rhd (M : \Pi\ P\ (\Pi\ X\ \univ)) \rhd \mta{dispAlgebra}\ \emb{a}\ (\mta{El}\ M@@) \,.
\end{align*}
with evident realisation functions
\begin{align*}
    &\emb{\_} : \Tms\ \Gamma\ (\mta{dispAlg}[\Msub{t}]) \to \mta{DispAlg}\ \emb t \\
    &\emb{\_} : \Tms\ \Gamma\ (\mta{dispAlgebra}\ t\ M) \to \mta{DispAlgebra}\ t\ M \,.
\end{align*}

Finally, we can get external sections over displayed algebras
\begin{align*}
     &\mta{Sec}\ M := \Tm\ (\Gamma \rhd P \rhd X)\ M \\
     &\mta{Coh}\ f := \forall a. f[\Msub{\mta{out}\ a; x\ a}] = \mta{apply}\ m\ f\ a \\
     &\mta{IntCoh}\ f := \forall a. \Tm\ \Gamma\ (\mta{Id}\ f[\Msub{\mta{out}\ a; x\ a}]\ (\mta{apply}\ m\ f\ a)) \\
     &\mta{Section}\ (M, m) := (f : \mta{Sec}\ M) \times \mta{Coh}\ f
\end{align*}
which have coherence rules using either the equality of the metatheory (\mta{Coh}) or
the propositional equality of the type theory (\mta{IntCoh}).
The $\mta{apply}$ function takes a displayed algebra, a section, and some
arguments $\mta{Args}$, and evaluates the section at those arguments.

These also have internal analogues
\begin{align*}
    &\mta{sec} : \Tel\ (\Gamma \rhd \mta{alg}\ T \rhd \mta{dispAlg}) \\
    &\mta{sec} := X\ x\ M\ m.\ \Pi\ P\ (\Pi\ X\ M) \\[1em]
    &\mta{coh} : \Tel\ (\Gamma \rhd (X, x) : \mta{alg}\ T\rhd (M, m) : \mta{dispAlg} \rhd \Pi\ P\ (\Pi\ X\ M)) \\[1em]
    &\mta{section} : \Tel\ (\Gamma \rhd \mta{alg}\ T \rhd \mta{dispAlg}) \\
    &\mta{section} := X\ x\ M\ m.\ \mta{sec} \rhd \mta{coh}
\end{align*}
which only use propositional equality.
Once again, we can define realisation functions
\begin{align*}
    &\emb{\_}_0 : \Tms\ \Gamma\ (\mta{section}[\Msub{t},\Msub{m}]) \to \mta{Sec}\ \emb{m} \\
    &\emb{\_}_1 : (t : \Tms\ \Gamma\ (\mta{section}[\Msub{t},\Msub{m}])) \to \mta{IntCoh}\ \emb{t}_0
\end{align*}
which produce only internal coherence proofs.

Finally we define a synonym for internal inductive algebras as a telescope
\[
    \mta{indAlg}\ T := \bullet \rhd \mta{alg}\ T \rhd \Pi\ \mta{dispAlg}\ \mta{section} \,.
\]

Next we will make use of the external versions of algebras, displayed algebras,
and sections in order to `freely' add inductive algebras to the inductive syntax
of a type theory in a strictly-positive but fully-applied manner. Later, we will
make use of the internal versions in order to be able to package inductive
algebras as a single syntactic entity that corresponds to data
representations.

\subsection{The core language, $\lambdaind$}\label{sub:lambdaind}

The languge $\lambdaind$, is a dependent type theory with $\Pi$, $\mta{Id}$, and
a universe $\univ : \univ$. We will not concern ourselves with a universe
hierarchy but our results should be readily extensible to such a type theory.
This language also has inductive families and global definitions. We follow a
similar approach
to Cockx~and~Abel~\cite{Cockx2018-fk} by packaging named inductive constructions
and function definitions into a signature $\Sigma : \Sig$, and indexing contexts
by signatures. The contexts $\Con$ in the resulting theory are pairs $(\Sigma :
\Sig) \times \Loc\ \Sigma$ where $\Loc\ \Sigma$ are local contexts given by a
closed telescope of types as usual. Substitutions only occur between contexts of
the same signature. Items in a signature $\Sigma$ can be either

\begin{itemize}
	\item function definitions $\mta{def}\ P\ A\ t$ for some parameters $P : \Loc\
		      \Sigma$, return type $A : \Ty\ (\Sigma, P)$ and implementation $t : \Tm\ A\ (\Sigma, P)$,
	\item postulates $\mta{post}\ P\ A$ for some parameters $P : \Loc\
		      \Sigma$ and return type $A : \Ty\ (\Sigma, P)$, or
	\item inductive type definitions $\mta{data}\ P\ T$ for some indices $P :
		      \Loc\ \Sigma$ and theory $T : \Theory\ (\Sigma, \bullet)\ P$.
\end{itemize}

We reuse the \mta{Theory} type defined in the previous section. This allows us
to define data types such as vectors
\begin{align*}
	 & \textit{Vect} : \mta{data}                                                                                                        \\
	 & \quad\begin{aligned}
		        \quad (\bullet & \rhd \univ \rhd \textit{Nat})\                                                                               \\
		        \quad (\bullet & \rhd \textit{nil} : \Pi\ (T : \univ)\ (\iota\ (T, \textit{zero}))                                                          \\
		        \quad          & \rhd \textit{cons} : \Pi\ (T : \univ)\ \Pi\ (n : \textit{Nat})\ \Pi\iota\ (T, n)\ \Pi\ T\ (\iota\ (T, \textit{succ}\ n))
	        \end{aligned}
\end{align*}
We do not make a distinction between parameters and indices, though this might
be desirable in an implementation because it generates elimination rules which
are structurally uniform in the parameters. Nevertheless, our system is
extensible to one with uniform parameters and we leave its formulation as an
implementation detail.

In order to actually construct inductive types in $\lambdaind$, we need to
extend the syntax with some term and type formers. First, we add a type former
\[
	\mta{D} : \mta{data}\ P\ T \in \Sigma \to \Ty\ (\Sigma, \Delta \rhd P)
\]
which, given a data definition $i$ in $\Sigma$, and terms for its
indices $p$, constructs the data type $(\mta{D}\ i)[p]$. The relation $I \in
\Sigma$ finds items in a signature, to be thought of in a similar way to how
$\mta{Var}\ \Gamma\ A$ defines variables for type $A$ in a local context
$\Gamma$. It is evidently a decidable relation, and is a proposition for a fixed
$I$ and $\Sigma$.

Additionally, we add a constructor term
\[
	\mta{C} :\ \forall i.\ \mta{Algebra}\ T\ (\mta{D}\ i)
\]
which fully applied, defines the data constructor $\mta{C}\ a$ of type
$(\mta{D}\ i)[\Msub p]$ for arguments $a$, by `freely' extending the syntax with
an algebra for the type family $\mta{D}\ i$. The (strictly positive) occurrences
of $\mta{Tm}$ in $\mta{Algebra}$ are part of the inductive syntax of the type
theory. We can now construct, for example, natural numbers as
\[
    \mta{C}_{\textit{Nat}}\ (\textit{succ}, (\mta{C}_{\textit{Nat}}\ (\textit{zero}, (\,))) : \mta{Tm}\ \Gamma\ (\mta{D}\ \textit{Nat}) \,.
\]

Next, we add an eliminator term
\[
	\mta{E} :\ \forall i.\ (m : \mta{DispAlg}\ \mta{C}_i) \to \mta{Sec}\ m
\]
which given a data definition $i$ in $\Sigma$, a motive and methods for $i$,
eliminates each $d : (\mta{D}\ i)[\Msub p]$ into $M[\Msub{p;d}]$. This captures
the induction principle of the data type. The coherence part of the section is
captured by an equality constructor in the syntax
\[
	\mta{E-id} :\ \forall i.\ (m : \mta{DispAlg}\ \mta{C}_i) \to \mta{Coh}\ (\mta{E}_i\ m)
\]
Once again, expanding all the definitions involved leads to positive occurrences for
the syntactic categories of the type theory.
\begin{lemma}
	The constructor algebra $\mta{C}_i$ of a data type $i$ is inductive.
	\begin{proof}
		For every displayed algebra $m$ over $\mta{C}$ we get a section $(\mta{E}\ m, \mta{E-id}\ m)$.
	\end{proof}
\end{lemma}

Finally, we add terms to the language for global function definitions and postulates
\begin{align*}
	\mta{F} : \mta{def}\ P\ A\ t \in \Sigma \to \Tm\ (\Sigma, \Delta \rhd P)\ A \\
	\mta{P} : \mta{post}\ P\ A \in \Sigma \to \Tm\ (\Sigma, \Delta \rhd P)\ A
\end{align*}
along with an equality constructor for function definitions
\begin{align*}
	\mta{F-id} : \forall i.\ \mta{F}\ i = t \,.
\end{align*}

The language we have defined thus far is sufficient to express a lot of the
programs which can be written in a modern proof assistant. Next, we will explore
how to extend this language to support data representations as explored earlier
in the paper.

\subsection{Extending $\lambdaind$ with representations} \label{sub:lambdarep}

We extend the language $\lambdaind$ to form $\lambdarep$, which allows users to
define custom representations for inductive types and global functions. The
machinery of algebras that we have developed in \cref{sub:algebras} allows for a
very direct definition of representations.

\begin{definition}
	A representation of a data type $\mta{data}\ P\ T$ is an inductive algebra for $T$.
\end{definition}

We first modify the syntax for signatures $\Sig$ to introduce representations:
\begin{align*}
	 & \bullet : \Sig \\
	 & \rhd : (\Sigma : \Sig) \to \Item\ \Sigma \to \Sig \\
	 & \unrhd : (\Sigma : \Sig) \to (I : \Item\ \Sigma) \to \Rep\ \Sigma\ I \to \Sig \,.
\end{align*}
Representations in turn are defined as
\begin{align*}
& \Rep : (\Sigma : \Sig) \to \Item\ \Sigma \to \Set \\
& \mta{data-rep} : \Tms\ (\Sigma, \epsilon)\ (\mta{indAlg}\ T) \to \Rep\ \Sigma\ (\mta{data}\ P\ T) \\
& \mta{def-rep} : (x : \Tm\ (\Sigma, P)\ A) \to \Tm\ (\Sigma, P)\ (\mta{Id}\ x\ t) \to \Rep\ \Sigma\ (\mta{def}\ P\ A\ t)
\end{align*}
We will write $\mta{data-rep}\ (R, r, Q)$ to unpack the telescope of an
inductive algebra for a data representation with carrier $R : \Tm\ (\Sigma,
\epsilon)\ (\Pi\ P\ \univ)$, algebra $r : \Tm\ (\Sigma, \epsilon)\
(\mta{algebra}[\Msub R])$, and induction $Q : \Tm\ (\Sigma, \epsilon)\ (\Pi\
\mta{dispAlg}\ \mta{section})[\Msub{R, r}]$.

We also include representations for definitions, where a definition can be
represented by a term propositionally equal to original definition, but perhaps
with better computational properties.
We use a decidable relation $R \in_i \Sigma'$ to mean that $R :
\mta{Rep}\ \Sigma\ I$ is the representation of an item $I : \mta{Item}\ \Sigma$
where $i : I \in \Sigma'$.
This relation is a proposition, so it is proof-irrelevant. Furthermore, it is stable under
weakening of contexts and signatures, because each item can only be represented once in a signature.



To allow reasoning about representations internally to $\lambdarep$ we add a
type former
\begin{equation}\label{eq:repr-ty}
	\MRepr{} : \Ty\ \Gamma \to \Ty\ \Gamma
\end{equation}
along with two new terms in the syntax, forming an isomorphism
\begin{equation}\label{eq:repr-iso}
	\Mrepr{} : \Tm\ \Gamma\ T \simeq \Tm\ \Gamma\ (\MRepr\ T) : \Munrepr{} \,.
\end{equation}
which holds by equality constructors and preserves $\Pi$, $\mta{Id}$ and
universes. The type $\MRepr\ T$ is the defined representation of the type $T$.
The term $\Mrepr{}$ takes a term of type $T$ to its representation of type
$\MRepr\ T$, and $\Munrepr{}$ undoes the effect of $\Mrepr{}$, treating a
represented term as an inhabitant of its original type. These new constructs
come with equality constructors in the syntax
shown in \cref{fig:lambdaind-repr-coherence-pi-univ}.
\begin{figure}[H]
  \begin{minipage}[t]{0.5\textwidth}%
  \begin{alignat*}{1}
  & \mta{reprr} : \Munrepr\ (\Mrepr\ t) \equiv t \\
  & \mta{reprl} : \Mrepr\ (\Munrepr\ t) \equiv t \\[1em]
  & \MRepr\text{-}\Pi : \MRepr\ {(\Pi\ T\ U)} \equiv \Pi\ T\ (\MRepr\ U) \\
  & \Mrepr\text{-}\lambda : \Mrepr\ {(\lambda\ u)} \equiv \lambda\ (\Mrepr\ u) \\
  & \Munrepr\text{-}\lambda : \Munrepr\ {(\lambda\ u)} \equiv \lambda\ (\Munrepr\ u) \\
  & \Mrepr\text{-}@ : \Mrepr\ (\ap f) \equiv \ap {(\Mrepr\ f)} \\
  & \Munrepr\text{-}@ : \Munrepr\ (\ap f) \equiv \ap {(\Munrepr\ f)} \\[1em]
  & \Mrepr[] : \Mrepr\ {(t[\sigma])} \equiv (\Mrepr\ {t})[\sigma] \\
  & \Munrepr[] : \Munrepr\ {(t[\sigma])} \equiv (\Munrepr\ {t})[\sigma] \\
  & \MRepr[] : \MRepr\ {(T[\sigma])} \equiv (\MRepr\ {T})[\sigma]
  \end{alignat*}
  \end{minipage}%
  \begin{minipage}[t]{0.5\textwidth}%
  \begin{alignat*}{1}
  & \MRepr\text{-}\univ : \MRepr\ {\univ} \equiv \univ \\
  & \Mrepr\text{-}\Code{} : \Mrepr\ {(\Code T)} \equiv \Code T \\
  & \Munrepr\text{-}\Code{} : \Munrepr\ {(\Code T)} \equiv \Code T \\[1em]
  & \MRepr\text{-}\mta{Id} : \MRepr\ (\mta{Id}\ a\ b) \equiv \mta{Id}\ (\Mrepr\ a)\ (\Mrepr\ b) \\
  & \Mrepr\text{-}\mta{refl} : \Mrepr\ (\mta{refl}\ u) \equiv \mta{refl}\ (\Mrepr\ u) \\
  & \Munrepr\text{-}\mta{refl} : \Munrepr\ (\mta{refl}\ u)  \equiv \mta{refl}\ (\Munrepr\ u) \\
  & \Mrepr\text{-}\mta{J} : \Mrepr\ (\mta{J}\ C\ w\ e) \\ & \qquad \qquad  \equiv \mta{J}\ (\mta{Repr}\ C)\ (\mta{repr}\ w)\ e \\
  & \Munrepr\text{-}\mta{J} : \Munrepr\ (\mta{J}\ (\mta{Repr}\ C)\ w\ e) \\ &  \qquad \qquad  \equiv \mta{J}\ C\ (\mta{unrepr}\ w)\ e
  \end{alignat*}
  \end{minipage}%
  \caption{Coherence of the representation operators with substitutions, $\Pi$, $\mta{Id}$,
  universes and codes. The terms $\MRepr\ (\El{t})$, $\Mrepr\ (\pi_2 \sigma)$ and
  $\Munrepr\ (\pi_2 \sigma)$ do not reduce.}
  \label{fig:lambdaind-repr-coherence-pi-univ}
\end{figure}

So far the representation operators do not really do much other than commute
with almost everything in the syntax. In order to make
them useful, we need to define how they compute when they encounter data types
which are represented in the signature.
In the following rules, $r : \mta{data-rep}\ (R, r, Q) \in_i \Sigma$.
Firstly, we define the reduction that occurs when a type $\mta{D}\ i$ is represented,
\begin{equation}
  \mta{Repr-D} : \forall r.\ \MRepr\ (\mta{D}\ i) = \mta{El}\ R@ \,, \label{eq:lambdaind-Repr-D}
\end{equation}
yielding the carrier $R$ of the inductive algebra that represents it (after
converting it from a function into the universe to a type family).

Additionally, we can add a rule for representing constructors, albeit in propositional form, where
\begin{align*}
&\mta{repr-C} : \forall r.\ \Tm\ (\Sigma, \Delta)\ (\mta{Id}\ (\Mrepr\ (\mta{C}\ a))\ (\emb{r}\ a^\mta{Repr}))
\end{align*}
Here, the operation $\_^{\mta{Repr}}$ is used to apply the term former
$\mta{repr}$ to the recursive part of the arguments $a$. This is definable
because $\mta{Args}\ T\ X$ is natural in $X$ as it is a sum of products. The
full construction can be found in \cref{app:reprs} of the appendix

One might be tempted to make this equality definitional too. Unfortunately, this
would render conversion checking undecidable, because if one applies
$\mta{unrepr}$ to a term $\Mrepr\ (\mta{C}\ a)$ which has already been reduced
to its representation, $\mta{unrepr}\ (\emb{r}\ a^{\mta{Repr}})$, there is no
clear way to decide that this is convertible to $\mta{C}\ a$ even though the
definitional equality rules would imply that it is (due
to the annihilation of $\mta{repr}$ and $\mta{unrepr}$). There is no
equivalent of $\mta{unrepr}$ for types, so \eqref{eq:lambdaind-Repr-D} preserves
the decidability of conversion checking.


We can also add a propositional equality rules for representing eliminators.
First, representing an eliminator just applies $\mta{repr}$ to the motive and methods:
\begin{align*}
&\mta{repr-motive-E} : \forall r.\ \Tm\ (\Sigma, \Delta)\ (\mta{Id}\ (\Mrepr\ (\mta{E}\ m))\ (\mta{E}\ m^\mta{Repr})) \\
&\mta{unrepr-motive-E} : \forall r.\ \Tm\ (\Sigma, \Delta)\ (\mta{Id}\ (\Munrepr\ (\mta{E}\ m))\ (\mta{E}\ m^\mta{Unrepr}))
\end{align*}
Additionally, eliminating something using $\mta{E}$ should be the same as
eliminating the representation of that thing using the represented eliminator $Q$:
\begin{align*}
&\mta{repr-methods-E} : \forall r.\ \Tm\ (\Sigma, \Delta)\ (\mta{Id}\ (\mta{E}\ m)\ (s.\ (\emb{Q}_0\ m^{\mta{Repr*}})[\Msub{\mta{repr}\ s}])))
\end{align*}
Above we use more auxilliary definitions which `represent' the carriers of
algebras, as well as displayed algebras:
\begin{align*}
\_^{\mta{Repr}} &: \mta{Algebra}\ T\ X \to \mta{Algebra}\ T\ (\mta{Repr}\ X) \\
 \_^{\mta{Repr}} &: \mta{DispAlgebra}\ a\ M \to \mta{DispAlg}\ a\ (\MRepr\ M) \\
 \_^{\mta{Repr}*} &: \mta{DispAlgebra}\ a\ M \to \mta{DispAlg}\ a^{\mta{Repr}}\ (p\ x .\ M[\Msub{p;\mta{unrepr}\ x}])
\end{align*}
These are defined straightforwardly; we represent outputs in a positive position
using $\mta{repr}$ and unrepresent inputs in a negative position using
$\mta{unrepr}$. The full definitions can be found in \cref{app:reprs} of the
appendix.

We do not need an additional equality rule for representing function definitions
as this is given by the equality proof $p$ in the definition of a
representation $\mta{def-repr}\ t\ p$, when accounting for the definitional
equality between a definition and its implementation.

\subsection{Normalisation by evaluation for $\lambdarep$}

To demonstrate that definitional equality is decidable in $\lambdarep$ with the addition
of the representation operators, we can define a syntax of values, and then show that
every term uniquely corresponds to a value.

\begin{lemma}
	The term formers $\Mrepr{}$ and $\Munrepr{}$ are injective, i.e.
	$\Mrepr\ x = \Mrepr\ y \to x = y$ and $\Munrepr\ x = \Munrepr\ y \to x = y$.
	\begin{proof}
				By applying $\mta{unrepr}/\mta{repr}$ to both sides
				followed by the rule $\mta{reprr}/\mta{reprl}$.
	\end{proof}
\end{lemma}


\section{Translating from $\lambdarep$ to $\lambdaind$}

We can define a translation step $\R$ from $\lambdarep$ to
$\lambdaind^{\lang{ext}}$, meant to be applied during the compilation process.
More specifically, the translation target is the extensional flavour of
$\lambdaind$ by adding the equality reflection rule. Doing so results in undecidable
type checking, but this is not a problem because type checking is decidable
$\lambdarep$ and we only apply this transformation after typechecking (when we
already know that everything is well-typed).


This translation is defined over the syntax of $\lambdarep$
\cite{Boulier2017-cm} such that definitional equality is preserved. Overall,
$\R$ preserves the structure of $\lambdarep$, but maps constructs to
their terminal representations.
First, we define a translation of signatures $\R : \Sig_\rep \to \Sig_\ind^\lang{ext}$ as
\[
\R\ \bullet := \bullet \qquad \R\ (\Sigma \rhd I) := \R \Sigma \rhd \R I \qquad \R\ (\Sigma \unrhd I \ R) := \R \Sigma
\]
which erases all items with defined representations.
This utilises a translation of items $\R : \Item_\rep\ \Sigma \to \Item_\ind^\lang{ext}\ \R
\Sigma$ which simply recurses on all subterms with $\R$.
Types are translated as
\begin{align*}
  & \R : \Ty_\rep\ (\Sigma, \Delta)\ \to \Ty_\ind^\lang{ext}\ (\R \Sigma, \R \Delta) \\
  & \R\ (\mta{D}\ i) := \begin{cases}
  \R\ (\mta{El}\ R@) & \text{if $\mta{data-rep}\ (R, r, Q) \in_i \Sigma$} \\
  \mta{D}\ \R i & \text{otherwise}
  \end{cases} \\
  & \R\ (\MRepr\ T) := \R T \\
  & \text{(otherwise recurse on all subterms with $\R$)}
\end{align*}
This mirrors the definitional equality rules of $\mta{Repr}$, but $\R$ is applied
to all subterms.
Similarly, terms are translated as
\begin{align*}
  & \R : \Tm_\rep\ (\Sigma, \Delta)\ T \to \Tm_\ind^\lang{ext}\ (\R \Sigma, \R \Delta)\ \R T \\
  &\R\ (\mta{C}_i\ a) = \begin{cases}
      \emb{\R r}\ \R a & \text{if}\ \mta{data-rep}\ (R, r, Q) \in_i \Sigma \\
      \mta{C}_{\R i}\ \R a & \text{otherwise}
  \end{cases} \\
  &\R\ (\mta{E}_i\ m) = \begin{cases}
      \emb{\R Q}_0\ \R m & \text{if}\ \mta{data-rep}\ (R, r, Q) \in_i \Sigma \\
      \mta{E}_{\R i}\ \R m & \text{otherwise}
  \end{cases} \\
  &\R\ (\mta{F}_i) = \begin{cases}
        \R t & \text{if}\ \mta{def-rep}\ (t, p) \in_i \Sigma \\
        \mta{F}_{\R i} & \text{otherwise}
    \end{cases} \\
  & \R\ (\Mrepr\ t) := \R t \\
  & \R\ (\Munrepr\ t) := \R t \\
  & \R\ (\mta{repr-C}_i\ a) := \mta{refl} \\
  & \R\ (\mta{repr-motive-E}_i\ m) := \mta{refl} \\
  & \R\ (\mta{unrepr-motive-E}_i\ m) := \mta{refl} \\
  & \R\ (\mta{repr-methods-E}_i\ m) := \mta{refl} \\
  & \text{(otherwise recurse on all subterms with $\R$)}
\end{align*}
Constructor, eliminator and definition translations mirror the equality rules in
\cref{sub:lambdarep}, but apply $\R$ to all subterms rather than only the
recursive occurrences of the data type being represented. As a result, all of
the propositional equality constructors are translated to reflexivity, since
after applying $\R$ both sides are identical.

The equality constructors of the syntax of $\lambdarep$ must also be translated.
The base equalities of the type theory are preserved by their counterparts in $\lambdaind^\lang{ext}$.
The coherence rules for representation operators
(\cref{fig:lambdaind-repr-coherence-pi-univ}) are preserved by metatheoretic
reflexivity on the other side, since all representation operators are erased.
Finally, coherence rules for definitions $\mta{F}$ and eliminators $\mta{E}$ are
preserved by reflecting the propositional coherence rules provided by their
defined representations:
\begin{align*}
& \mta{ap}_\R\ (\mta{E-id}_i\ m) :=
\begin{cases}
    \mta{reflect}\ \emb{\R Q}_1\ \R m & \text{if}\ \mta{data-rep}\ (R, r)\ Q \in_i \Sigma \\
    \mta{E-id}_{\R i}\ \R m & \text{otherwise}
    \end{cases} \\
    & \mta{ap}_\R\ (\mta{F-id}_i) :=
    \begin{cases}
        \mta{reflect}\ \R p & \text{if}\ \mta{def-rep}\ (t, p) \in_i \Sigma \\
        \mta{F-id}_{\R i} & \text{otherwise}
        \end{cases} \\
& \text{(otherwise recurse on all equality constructors with $\mta{ap}_\R$)}
\end{align*}
Thus, by construction, $\R$ is sound with respect to typing and definitional equality.

\begin{theorem}
    $\R$ preserves typing and definitional equality.
    \begin{proof}
        By construction, since it is defined on well-typed syntax quotiented by equality.
    \end{proof}
\end{theorem}

\begin{theorem}
    $\R$ is a left-inverse of the evident inclusion $i : \lambdaind \hookrightarrow \lambdarep$.
    \[
        (t : \Tm_{\ind}\ \Gamma\ A) \to \R(i t) = t
    \]
    \begin{proof}
        The inclusion produces signatures in $\lambdarep$ without the $\unrhd$ constructor. Thus no
        items have defined representations. Furthermore, the action of $\R$ on
        the image of $i$ does not invoke the equality reflection rule. With that
        constraint, and by induction on the syntax, $\R \circ i$ is the identity
        function.
    \end{proof}
\end{theorem}

\subsection{Computational irrelevance}

In order to reason about computational irrelevance, we assume that there is
an additional program extraction step $\mathcal{E}$ from $\lambdaind$ into some
simply-typed calculus, denoted by vertical bars $|x|$. As opposed to
$\R$, $\mathcal{E}$ operates on the unquotiented syntax of $\lambdaind$. This
can be justified by interpreting the quotient-inductive constructions from
before into setoids \cite{Kovacs2022-vb}. This kind of transformation is used
because we might want to compile two definitionally equal terms differently. For
example, we might not always want to reduce function application redexes. We
will use the \texttt{monospace} font for terms in $\lambda$.

\begin{definition}
    A function $f : \mta{Tm}\ \Gamma\ (\Pi\ A\ B)$, is \emph{computationally irrelevant} if
    $|\R A| = |\R B|$ and $|\R f| = \texttt{id}$.
\end{definition}

\begin{theorem}
	The type former $\MRepr{}$ is injective up to internal isomorphism, i.e.
	\begin{equation}
	\mta{Repr}\ T = \mta{Repr}\ T' \to \Tm\ \Gamma\ (\mta{Iso}\ T\ T')
	\end{equation}
	Moreover, this isomorphism is computationally irrelevant.
	\begin{proof}
	The forward direction is given by first applying $\mta{repr}$ to $t$,
	transporting over the given equality and then applying $\mta{unrepr}$. The
	backward direction is given by applying $\mta{repr}$ to $t'$, transporting
	over the equality and then applying $\mta{unrepr}$. The coherence holds by
	the rules $\mta{reprr}$ and $\mta{reprl}$. After applying $\R$, all
	representation operators are erased and the isomorphism is the identity on both
	sides (even before extraction).
	\end{proof}
\end{theorem}

Consider extending our languages with usage-aware
subset $\Sigma$-types
\[
\{ \_ \mid \_ \} : (A : \Ty\ \Gamma) \to \Ty\ (\Gamma \rhd A) \to \Ty\ \Gamma
\]
in such a way that $\MRepr$ and $\R$ preserve them, but such that the extraction
step erases the right component, i.e. $|\{A \mid B\}| = |A|$, $|(x, y)| = |x|$ and $|\pi_1 x| =
|x|$.\footnote{This can be implemented using quantitative type theory for example.}
Then if we have an inductive family $G : \mta{data}\ (\bullet \rhd I)\ T_G
\in \Sigma$ over some index type $I$, and an inductive type $F : \mta{data}\ \bullet\
T_F \in \Sigma$ such that $G$ is represented by a refinement $f : \Tm\
(\Sigma,\bullet)\ (\Pi\ (\mta{D}\ F)\ I)$ of $F$,
\[
    \mta{data-rep}\ (i.\ \{ x : \mta{D}\ F \mid \mta{Id}\ (\mta{app}\ f\ x)\ i \}, r, Q) \in_G \Sigma \,,
\]
then we can construct computationally irrelevant forgetful and recomputation functions
\begin{align*}
&\mta{forget}_i : \Tm\ \Gamma\ (\Pi\ (\mta{D}\ G)[i]\ (\mta{D}\ F)) \\
&\mta{forget}_i = \lambda g.\ \pi_1\ (\mta{repr}\ g) \\[1em]
&\mta{remember} : \Tm\ \Gamma\ (\Pi\ (x : \mta{D}\ F)\ (\mta{D}\ G[\mta{app}\ f\ x])) \\
&\mta{remember} = \lambda x.\ (\mta{unrepr}\ x, \mta{refl})
\end{align*}
Clearly $|\R\ \mta{forget}_i| = |\R\ \mta{remember}| = \texttt{id}$.
