\section{A type system for data representations}\label{sec:type-system}


In this section, we will develop an extension of dependent type theory with
inductive families and custom data representations. We start in
\cref{sub:algebras} by exploring the semantics of data representations in terms
of algebras for signatures. In \cref{sub:lambdaind}
we define a core language with inductive families $\lambdaind$. In
\cref{sub:lambdarep}, we extend this language with data representations to form
$\lambdarep$. All of the examples in the paper are written in a surface language
that elaborates to $\lambdarep$. The dependent pattern matching can be
elaborated to internal eliminators by standard techniques
\cite{Goguen2006-sy,Cockx2018-fk}. The $\lambdaind/\lambdarep$ languages use eliminators instead
of pattern matching. \todo{This should be expanded upon and not be here. It is a pretty central part of the paper.}

% We work in an extensional metatheory with a small universe $\Set$, $(a : A)
% \times B$ for dependent pairs, $(a : A) \to B$ for dependent products, and $=$
% for equality, and an Agda-like syntax.
Syntaxes for languages are defined in an intrinsically well-formed manner
quotiented by definitional equality \cite{Altenkirch2016-zc}, and with de-Bruijn
indices for variables. Weakening of terms is generally left implicit to reduce
syntactic noise, and often higher-order abstract syntax notation is used when
de-Brujin indices are implied. We will make use of the standard judgement forms
of type theory, extended to telescopes:

\begin{alignat*}{2}
&\Gamma \vdash \Delta \tel                && \qquad \text{$\Delta$ is a telescope in $\Gamma$.} \\
&\Gamma \vdash \delta :: \Delta           && \qquad \text{$\delta$ is a spine (list of terms) matching telescope $\Delta$.} \\
&\Gamma \vdash \Delta = \Delta'           && \qquad \text{$\Delta$ and $\Delta'$ are equal telescopes in $\Gamma$.} \\
&\Gamma \vdash \delta = \delta' :: \Delta && \qquad \text{$\delta$ and $\delta'$ are equal spines matching telescope $\Delta$.}
\end{alignat*}

Below are the formation rules for telescopes and term lists.
Since everything is intrinsically well-formed, all required pre-conditions are
implied for every inference rule.

\begin{figure}[H]
  \begin{mathpar}
  \inferrule[Tel-Empty]{ }{\Gamma \vdash \bullet \tel}
  \and
  \inferrule[Tel-Cons]{\Gamma \vdash \Delta \tel \\ \Gamma, \Delta \vdash A \type}{\Gamma \vdash (\Delta, A) \tel}
  \\
  \inferrule[Spine-Empty]{ }{\Gamma \vdash (\,) :: \bullet} \and
  \inferrule[Spine-Cons]{\Gamma \vdash \delta :: \Delta \\ \Gamma \vdash a : A[\delta]}{\Gamma \vdash (\delta, a) :: (\Delta, A)}
  \end{mathpar}
  \caption{Rules for forming telescopes and spines. Extending contexts by
  telescopes (such as $\Gamma, \Delta$) is defined mutually with these rules.}
\end{figure}




\newcommand{\ValidCase}{\mta{ValidCase}}

\subsection{Algebraic signatures}

A representation of a data type must be able to emulate the behaviour of the
original data type. In turn, the behaviour of the original data type is
determined by its elimination, or induction principle. This means that a
representation of a data type should provide an implementation of induction of
the same `shape' as the original. Induction can be characterised in terms of
algebras and displayed algebras of algebraic signatures.

Algebraic signatures \cite{Adamek2010-ls,Kovacs2023-gq} consist of a list of operations, each with a specified
arity. There are many flavours of algebraic signatures with varying degrees of
expressiveness. For this paper, we are interested in algebraic signatures which can
be used as a syntax for defining inductive families in a type theory. Thus, we define
two new judgement forms:
\begin{alignat*}{2}
&\Gamma \vdash S \sig \Delta  && \qquad \text{$S$ is a signature with indices $\Delta$ in context $\Gamma$.} \\
&\Gamma \vdash O \op \Delta   && \qquad \text{$O$ is an operation for a signature with indices $\Delta$ in context $\Gamma$.}
\end{alignat*}
Signatures are lists of operations, and operations build up constructor types.

\begin{figure}[H]
  \begin{mathpar}
  \inferrule[Sig-Empty]{\Gamma \vdash \Delta \tel}{\Gamma \vdash \epsilon \sig \Delta}
  \and
  \inferrule[Sig-Cons]{\Gamma \vdash \Delta \tel \\ \Gamma \vdash O \op \Delta}{\Gamma \vdash (S \rhd O) \sig \Delta}
  \\
  \inferrule[Op-Ext]{\Gamma \vdash A \type \\ \Gamma, A \vdash O \op \Delta}
  {\Gamma \vdash (A\ \to\external O) \op \Delta} \and
  \inferrule[Op-Int]{\Gamma \vdash \delta :: \Delta \\ \Gamma \vdash O \op \Delta}
  {\Gamma \vdash (\iota\ \delta \to\internal O) \op \Delta} \and
  \inferrule[Op-Ret]{\Gamma \vdash \delta :: \Delta}
  {\Gamma \vdash (\iota\ \delta) \op \Delta}
  \end{mathpar}
  \caption{Rules for forming signatures and operations.}
\end{figure}

Each signature is described by an associated telescope of indices $\Delta$, and a
\emph{finite list} of operations:
\begin{itemize}
    \item $A \to\external O$, a (dependent) abstraction over some type $A$ from the
      type theory, of another operation $O$.
    \item $\iota\ \delta \to\internal \ O$, an
      abstraction over a recursive occurence of
      the object being defined, with indices $\delta$, of another operation
      $O$.
    \item $\iota\ \delta$, a constructor of the object being defined, with indices $\delta$.
\end{itemize}
For example, the signature of natural numbers has an empty telescope of indices. It is defined as
$\Gamma \vdash (\epsilon \rhd \iota\ (\,) \rhd \iota\ (\,) \to\internal \iota\ (\,)) \sig \bullet$.
We can add labels to aid readability, and omit index spines if they are empty:
\[
\Gamma \vdash (\epsilon \rhd \textit{zero} : \iota \rhd \textit{succ} : \iota\ \to\internal \iota) \sig \bullet
\]
Notice that this syntax only allows occurrences of $\iota$ in positive
positions, which is a requirement for inductive types.
Different classes of theories and quantification are explored in detail by
Kov\'acs \cite{Kovacs2023-gq}.

\subsection{Algebras, displayed algebras and inductive algebras} \label{sub:algebras}

In order to make use of our definition for theories, we would like to be able to
interpret the structure into a semantic universe. An algebra for a signature
$\Gamma \vdash S \sig \Delta$ and carrier type $\Gamma, \Delta \vdash X \type$
defines a way to interpret the structure of $S$ in terms of the type $X$. This
produces a telescope which matches the structure of $S$ but replaces each
occurrence of $\iota$ with $X$. The function arrows $\to\internal$ and
$\to\external$ in $S$ are interpreted as the function arrow $\to$
of the type theory.
An algebra over the signature of natural numbers over $\Gamma \vdash X \type$ is a spine which
matches the telescope
\[
  \bullet,\ \textit{zero}: X,\ \textit{succ}: X \to X.
\]
We have a choice in terms of how much we want to interpret $T$ in the object theory,
and how much we want to interpret it in the \emph{metatheory}. Here we have chosen to interpret
a theory as a metatheoretical iterated pair type, but an operation as a term in the object theory.

Very special classes of algebras support \emph{induction}.
To formulate induction, we first need to define displayed algebras.
A displayed algebra $(M, m)$ over an algebra $(X, a)$ for a signature $T$ with
carrier $M$ mirrors the shape of $T$ like an algebra does, but each recursive
occurrence $\iota$ is now replaced by $M$ applied to the corresponding value of
the algebra. The displayed algebras for natural numbers are
\begin{align*}
	\mta{DispAlg}\ (X, \textit{zero}, \textit{succ}) & \simeq (M : \Ty\ (\Gamma \rhd X))                                                      \\
	                               & \quad \times (\textit{zero'} : \Tm\ \Gamma\ M[\Msub{\textit{zero}}])                                            \\
	                               & \quad \times (\textit{succ'} : \Tm\ \Gamma\ (\Pi\ (x : X)\ \Pi\ M[\Msub{x}]\ M[\Msub{\textit{succ}\ x}]))
\end{align*}
The type $M$ is often called the \emph{motive}, and $m$ the \emph{methods}.
A section is a dependent function from $X$ to $M$ which takes its values from
the displayed algebra. For natural numebrs,
\begin{align*}
	\mta{Section}\  & \{(X, \textit{zero}, \textit{succ})\}\ (M, \textit{zero'}, \textit{succ'})                                                                                           \\
	                & \simeq (f : \Tm\ \Gamma\ (\Pi\ (x : X)\ M[\Msub x]))                                                                                   \\
	                & \quad \times (f\ \textit{zero} = \textit{zero'}) \times ((x : \Tm\ \Gamma\ X) \to f\ (\textit{succ}\ x) = \textit{succ'}\ x\ (f\ x))
\end{align*}

\begin{definition}
An algebra is \emph{inductive} if every displayed algebra over it has a section.
\end{definition}
A displayed algebra $(M, m)$ is the input of induction: a proof of $M$ for each structural case in $X$ by $m$.
A section $f$ is the output: a proof of $M$ for all $X$ constructed from $m$.

\subsection{Internal and external constructions}

For the remainder of the paper we choose a fixed representation for algebras,
displayed algebras and sections. We will omit the full definitions here for
space, but where missing they can be found in \cref{app:algebras} of the appendix.

We define these constructions in two ways: one that is fully internal to the
object theory and the other that is partially external (using the metatheory).
In particular, all the external constructions are \emph{positive} in the
syntax of the object theory (\mta{Ty}, \mta{Tm}, \mta{Tel}, etc) so that
they can be added into the syntax retroactively.

First, we define an `external' version of algebras
\begin{align*}
    &\mta{Algebra} : (T : \mta{Sig}\ \Gamma\ P) \to \Ty\ (\Gamma \rhd P) \to \Set \\
    &\mta{Algebra}\ T\ X := (a : \mta{In}\ T\ X) \to \Tm\ \Gamma\ X[\Msub{\mta{out}\ a}] \\[1em]
    &\mta{Alg}\ T := (X : \Ty\ (\Gamma \rhd P)) \times \mta{Algebra}\ T\ X \,,
\end{align*}
which take some arguments $\mta{In}$ and produce the output $X$
evaluated at the appropriate index $\mta{out}\ a$ based on the arguments.
This is the uncurried version of the presentation with $\Pi$ types.
The type $\mta{In}$ is defined as $(v : \mta{Var}\ T) \times \Tms\ \Gamma\
(\mta{in}\ (T\ v)\ X)$ for where $\mta{Var}\ T$ indexes
operations in theories. The function
\begin{align*}
    &\mta{in} : \mta{Op}\ \Gamma\ P \to \Ty\ (\Gamma \rhd P) \to \Tel\ \Gamma \\
    &\mta{in}\ (\Pi\ A\ B)\ X := \bullet \rhd (a : A) \rhd \mta{in}\ B[\Msub a]\ X \\
    &\mta{in}\ (\Pi\iota\ p\ B)\ X := \bullet \rhd X[\Msub p] \rhd \mta{in}\ B\ X \\
    &\mta{in}\ (\iota\ p)\ X := \bullet \,
\end{align*}
computes a telescope in the object theory, of the input arguments to the algebra
element of a given operation. For the output, there is a function to compute
the indices. It is defined as $\mta{out}\ \{T\ v\}\ a\ X$, where
\begin{align*}
    &\mta{out} : \{O : \Op\ \Gamma\ P\} \to \Tms\ \Gamma\ (\mta{in}\ O\ X) \to \Ty\ \Gamma \to \Tms\ \Gamma\ P \\
    &\mta{out}\ \{\Pi\ A\ B\}\ (a, t)\ X := \mta{out}\ \{B[\Msub a]\}\ t\ X \\
    &\mta{out}\ \{\Pi\iota\ p\ B\}\ (r, t)\ X := \mta{out}\ \{B\}\ t\ X \\
    &\mta{out}\ \{\iota\ p\}\ (\,)\ X := p \,.
\end{align*}
We can also define an internal version of algebras as telescopes of $\Pi$ types
\begin{align*}
    &\mta{algebra} : \mta{Sig}\ \Gamma\ P \to \Ty\ (\Gamma \rhd P) \to \Tel\ \Gamma \\
    &\mta{algebra}\ \bullet\ X := \bullet \\
    &\mta{algebra}\ (T \rhd O)\ X := \mta{algebra}\ T\ X \rhd \Pi\ (a : \mta{in}\ O\ X)\ X[\Msub{\mta{out}\ O\ a\ X}] \\[1em]
    &\mta{alg}\ T := \bullet \rhd (X : \Pi\ P\ \univ) \rhd \mta{algebra}\ T\ (\mta{El}\ X@)  \,.
\end{align*}

All internal constructions have `realisation' functions into the metatheory
\begin{align*}
    \emb{\_} : \Tms\ \Gamma\ (\mta{alg}\ T) \to \mta{Alg}\ T \qquad \emb{\_} : \Tms\ \Gamma\ (\mta{algebra}\ T\ X) \to \mta{Algebra}\ T\ X \,.
\end{align*}

% We can similarly define internal displayed algebras over external algebras $(X,
% x) : \mta{Alg}\ T$ as
% \begin{align*}
%     &\mta{dispAlgebra}\statement that is true in a model (X, x) : \Tel\ (\Gamma \rhd M : \Ty\ (\Gamma \rhd P \rhd X)) \\
%     &\mta{dispAlg}\ (X, x) := \bullet \rhd M : \Ty\ (\Gamma \rhd P \rhd X) \rhd \mta{dispAlgebra}\ (X, x)
% \end{align*}
% and finally sections as
% \begin{align*}
%     &\mta{Sec}\ M := \Tm\ (\Gamma \rhd P \rhd X)\ M \\
%     &\mta{Coh}\ f := \forall a. f[\Msub{\mta{out}\ a; x\ a}] = m\ (\mta{disp}\ f\ a) \\
%     &\mta{Section}\ (M, m) := (f : \mta{Sec}\ M) \times \mta{Coh}\ f
% \end{align*}

A similar construction can be performed for displayed algebras over algebras
\begin{align*}
&\mta{dispAlgebra} : ((X, x) : \mta{Alg}\ T) \to \mta{Ty}\ (\Gamma \rhd P \rhd X) \to \Tel\ \Gamma \\
&\mta{DispAlg}\ (X, x) := (M : \mta{Ty}\ (\Gamma \rhd P \rhd X)) \times \mta{Tms}\ \Gamma\ (\mta{dispAlgebra}\ (X, x)\ M)
\end{align*}
as well as the telescopic internal equivalent $\mta{dispAlg} : \Tel\ (\Gamma \rhd \mta{alg}\ T)$. %
% \begin{align*}
%     &\mta{dispAlg} : \Tel\ (\Gamma \rhd \mta{alg}\ T) \\
%     &\mta{dispAlg} := a.\ \bullet \rhd (M : \Pi\ P\ (\Pi\ X\ \univ)) \rhd \mta{dispAlgebra}\ \emb{a}\ (\mta{El}\ M@@) \,.
% \end{align*}
Internal displayed algebras come with a realisation function $\emb{\_}$ too.
% : \Tms\ \Gamma\ (\mta{dispAlg}[\Msub{t}]) \to \mta{DispAlg}\ \emb t$ and
% $\emb{\_} : \Tms\ \Gamma\ (\mta{dispAlgebra}\ t\ M) \to \mta{DispAlgebra}\ t\ M$.
Finally, we construct sections over displayed algebras
\begin{align*}
     &\mta{Sec}\ M := \Tm\ (\Gamma \rhd P \rhd X)\ M \\
     &\mta{Coh}\ f := \forall v\ a.\ f[\Msub{\mta{dispOut}\ a}] = m\ (v, \mta{apply}\ f\ a) \\
     &\mta{IntCoh}\ f := \forall v\ a.\ \Tm\ \Gamma\ (\mta{Id}\ f[\Msub{\mta{dispOut}\ a}])\ (m\ (v, \mta{apply}\ f\ a)) \\
     &\mta{Section}\ (M, m) := (f : \mta{Sec}\ M) \times \mta{Coh}\ f  \,.
\end{align*}
which have coherence rules using either the equality of the metatheory (\mta{Coh}) or
the propositional equality of the object theory (\mta{IntCoh}).
The $\mta{apply}$ function takes the inputs for the algebra and a section,
and produces the inputs for the displayed algebra by evaluating the section.
Sections also have internal analogues
\[
    \mta{section} : \Tel\ (\Gamma \rhd \mta{alg}\ T \rhd \mta{dispAlg})
\]
which only use propositional equality.
As a result, the realisation functions for sections $\emb{f}_0 : \mta{Sec}\
\emb{m}$ and $\emb{f}_1 : \mta{IntCoh}\ \emb{f}_0$ produce only internal
coherence proofs.

Now we can define a synonym for internal inductive algebras as a telescope $\mta{indAlg}\ T := \bullet \rhd \mta{alg}\ T \rhd \Pi\ \mta{dispAlg}\ \mta{section}$
with realisations
\begin{align*}
    &\emb{\_}_0\ : \mta{Tms}\ \Gamma\ \mta{indAlg}[\Msub X] \to (m : \mta{DispAlg}\ X) \to \mta{Sec}\ m \\
    &\emb{\_}_1\ : (i : \mta{Tms}\ \Gamma\ \mta{indAlg}[\Msub X] \to (m : \mta{DispAlg}\ X) \to \mta{IntCoh}\ \emb{i}_0\ m \,.
\end{align*}
Next we will make use of the external versions of algebras, displayed algebras,
and sections in order to add inductive algebras as part of the well-typed
syntactical definition of a type theory in a strictly-positive, fully-applied
manner. Later, we will make use of the internal versions in order to be able to
package inductive algebras as a single syntactic entity that corresponds to data
representations.

\subsection{A type theory with inductive families, $\lambdaind$}\label{sub:lambdaind}

The languge $\lambdaind$, is a dependent type theory with $\Pi$, $\mta{Id}$ with
$\mta{uip}$, and a universe $\univ : \univ$. We will not concern ourselves with a
universe hierarchy but our results should be readily extensible to such a type
theory. This language also has inductive families and global definitions. We
follow a similar approach
to Cockx~and~Abel~\cite{Cockx2018-fk} by packaging named inductive constructions
and function definitions into a global context $\Sigma : \Glob$, and indexing local contexts
by global contexts. The contexts $\Con$ in the resulting theory are pairs $(\Sigma :
\Glob) \times \Loc\ \Sigma$ where $\Loc\ \Sigma$ are local contexts given by a
closed telescope of types as usual. Substitutions only occur between local contexts.
Items in a signature $\Sigma$ can be either

\begin{itemize}
	\item function definitions $\mta{def}\ P\ A\ t$ for some parameters $P : \Loc\
		      \Sigma$, return type $A : \Ty\ (\Sigma, P)$ and implementation $t : \Tm\ A\ (\Sigma, P)$,
	\item postulates $\mta{post}\ P\ A$ for some parameters $P : \Loc\
		      \Sigma$ and return type $A : \Ty\ (\Sigma, P)$, or
	\item inductive type definitions $\mta{data}\ P\ T$ for some indices $P :
		      \Loc\ \Sigma$ and signature $T : \Sig\ (\Sigma, \bullet)\ P$.
\end{itemize}

This allows us to define data types such as vectors
\begin{align*}
	 & \textit{Vect} : \mta{data}\ (\bullet \rhd \univ \rhd \textit{Nat})               \\
	 & \quad\begin{aligned}
		        \quad (\bullet & \rhd \textit{nil} : \Pi\ (T : \univ)\ (\iota\ (T, \textit{zero}))                                                          \\
		        \quad          & \rhd \textit{cons} : \Pi\ (T : \univ)\ \Pi\ (n : \textit{Nat})\ \Pi\iota\ (T, n)\ \Pi\ T\ (\iota\ (T, \textit{succ}\ n)) \,.
	        \end{aligned}
\end{align*}
We do not make a distinction between parameters and indices for data types, but
our system is extensible to one with additional uniform parameters and we leave its
formulation as an implementation detail.

In order to actually construct inductive types in $\lambdaind$, we need to
extend the syntax with some term and type formers. First, we add a type former
\[
	\mta{D} : \mta{data}\ P\ T \in \Sigma \to \Ty\ (\Sigma, \Delta \rhd P)
\]
which, given a data definition $i$ in $\Sigma$, and terms for its
indices $p$, constructs the data type $(\mta{D}\ i)[p]$. The relation $I \in
\Sigma$ finds items in a global context, analogously to how
$\mta{Var}\ \Gamma\ A$ defines variables for type $A$ in a local context
$\Gamma$. It is a decidable relation and stable under substitutions and global weakening.

Additionally, we add a constructor term
\[
	\mta{C} :\ \forall i.\ \mta{Algebra}\ T\ (\mta{D}\ i)
\]
which fully applied, defines the data constructor $\mta{C}\ a$ of type
$(\mta{D}\ i)[\Msub p]$ for arguments $a$, by `freely' extending the syntax with
an algebra for the type family $\mta{D}\ i$. The (strictly positive) occurrences
of $\mta{Tm}$ in $\mta{Algebra}$ are part of the inductive syntax of the type
theory. We can now construct, for example, natural numbers as
\[
    \mta{C}_{\textit{Nat}}\ (\textit{succ}, (\mta{C}_{\textit{Nat}}\ (\textit{zero}, (\,))) : \mta{Tm}\ \Gamma\ (\mta{D}\ \textit{Nat}) \,.
\]

Next, we add an eliminator term
\[
	\mta{E} :\ \forall i.\ (m : \mta{DispAlg}\ \mta{C}_i) \to \mta{Sec}\ m
\]
which given a data definition $i$ in $\Sigma$, a motive and methods for $i$,
eliminates each $d : (\mta{D}\ i)[\Msub p]$ into $M[\Msub{p;d}]$. This captures
the induction principle of the data type. The coherence part of the section is
captured by an equality constructor in the syntax
\[
	\mta{E-id} :\ \forall i.\ (m : \mta{DispAlg}\ \mta{C}_i) \to \mta{Coh}\ (\mta{E}_i\ m) \,.
\]
\vspace{-2em}
\begin{lemma}
	The constructor algebra $\mta{C}_i$ of a data type $i$ is inductive.
	\begin{proof}
		For every displayed algebra $m$ over $\mta{C}$ we get a section $(\mta{E}\ m, \mta{E-id}\ m)$.
	\end{proof}
\end{lemma}

Finally, we add terms to the language for function definitions and postulates
\begin{align*}
	\mta{F} : \mta{def}\ P\ A\ t \in \Sigma \to \Tm\ (\Sigma, \Delta \rhd P)\ A \qquad \mta{P} : \mta{post}\ P\ A \in \Sigma \to \Tm\ (\Sigma, \Delta \rhd P)\ A
\end{align*}
along with an equality constructor for function definitions $\mta{F-id} : \forall i.\ \mta{F}\ i = t$.
The language we have defined thus far is comparable to the core language of a
proof assistant.

\subsection{Extending $\lambdaind$ with representations} \label{sub:lambdarep}

We extend the language $\lambdaind$ to form $\lambdarep$, which allows the
definition of custom representations for data types and global functions. The
machinery of algebras that we have developed in \cref{sub:algebras} allows for a
very direct definition of representations of data types: A representation for a
$\mta{data}\ P\ T$ is an inductive algebra for $T$.
Representations live alongside items in a global context, and each item only corresponds
to at most one representation. We achieve this by adding a constructor to global contexts
$\unrhd : (\Sigma : \Glob) \to (I : \Item\ \Sigma) \to \Rep\ \Sigma\ I \to \Glob$.
Representations are defined inductively by
\begin{align*}
% & \Rep : (\Sigma : \Sig) \to \Item\ \Sigma \to \Set \\
& \mta{datarep} : \Tms\ (\Sigma, \epsilon)\ (\mta{indAlg}\ T) \to \Rep\ \Sigma\ (\mta{data}\ P\ T) \\
& \mta{defrep} : (x : \Tm\ (\Sigma, P)\ A) \to \Tm\ (\Sigma, P)\ (\mta{Id}\ x\ t) \to \Rep\ \Sigma\ (\mta{def}\ P\ A\ t)
\end{align*}
We will write $\mta{datarep}\ (R, r, Q)$ to unpack the telescope of an inductive
algebra with carrier $R$, algebra $r$ and induction
$Q$. Representations for definitions are also included, where a definition can
be represented by a term propositionally equal to original definition, but
perhaps with better computational properties.

\subsection{Reasoning about representations} \label{sub:reasoningrep}

To allow reasoning about representations internally to $\lambdarep$ we add a
type former $\MRepr{} : \Ty\ \Gamma \to \Ty\ \Gamma$
along with two new terms in the syntax, forming an isomorphism
\begin{equation}\label{eq:repr-iso}
	\Mrepr{} : \Tm\ \Gamma\ T \simeq \Tm\ \Gamma\ (\MRepr\ T) : \Munrepr{}
\end{equation}
which preserves $\Pi$/$\mta{Id}$/$\univ$. The type $\MRepr\ T$ is the
defined representation of the type $T$. The term $\Mrepr{}$ takes a term of type
$T$ to its representation of type
$\MRepr\ T$, and $\Munrepr{}$ undoes the effect of $\Mrepr{}$, treating a
represented term as an inhabitant of its original type. These new constructs
come with equality constructors in the syntax
shown in \cref{fig:lambdaind-repr-coherence-pi-univ}.
\begin{figure}[H]
  \begin{minipage}[t]{0.5\textwidth}%
  \begin{alignat*}{1}
  & \mta{reprr} : \Munrepr\ (\Mrepr\ t) \equiv t \\
  & \mta{reprl} : \Mrepr\ (\Munrepr\ t) \equiv t \\[1em]
  & \MRepr\text{-}\Pi : \MRepr\ {(\Pi\ T\ U)} \equiv \Pi\ T\ (\MRepr\ U) \\
  & \Mrepr\text{-}\lambda : \Mrepr\ {(\lambda\ u)} \equiv \lambda\ (\Mrepr\ u) \\
  & \Munrepr\text{-}\lambda : \Munrepr\ {(\lambda\ u)} \equiv \lambda\ (\Munrepr\ u) \\
  & \Mrepr\text{-}@ : \Mrepr\ (\ap f) \equiv \ap {(\Mrepr\ f)} \\
  & \Munrepr\text{-}@ : \Munrepr\ (\ap f) \equiv \ap {(\Munrepr\ f)} \\[1em]
  & \Mrepr[] : \Mrepr\ {(t[\sigma])} \equiv (\Mrepr\ {t})[\sigma] \\
  & \Munrepr[] : \Munrepr\ {(t[\sigma])} \equiv (\Munrepr\ {t})[\sigma] \\
  & \MRepr[] : \MRepr\ {(T[\sigma])} \equiv (\MRepr\ {T})[\sigma]
  \end{alignat*}
  \end{minipage}%
  \begin{minipage}[t]{0.5\textwidth}%
  \begin{alignat*}{1}
  & \MRepr\text{-}\univ : \MRepr\ {\univ} \equiv \univ \\
  & \Mrepr\text{-}\Code{} : \Mrepr\ {(\Code T)} \equiv \Code T \\
  & \Munrepr\text{-}\Code{} : \Munrepr\ {(\Code T)} \equiv \Code T \\[1em]
  & \MRepr\text{-}\mta{Id} : \MRepr\ (\mta{Id}\ a\ b) \equiv \mta{Id}\ (\Mrepr\ a)\ (\Mrepr\ b) \\
  & \Mrepr\text{-}\mta{refl} : \Mrepr\ (\mta{refl}\ u) \equiv \mta{refl}\ (\Mrepr\ u) \\
  & \Munrepr\text{-}\mta{refl} : \Munrepr\ (\mta{refl}\ u)  \equiv \mta{refl}\ (\Munrepr\ u) \\
  & \Mrepr\text{-}\mta{J} : \Mrepr\ (\mta{J}\ C\ w\ e) \\ & \qquad \qquad  \equiv \mta{J}\ (\mta{Repr}\ C)\ (\mta{repr}\ w)\ e \\
  & \Munrepr\text{-}\mta{J} : \Munrepr\ (\mta{J}\ (\mta{Repr}\ C)\ w\ e) \\ &  \qquad \qquad  \equiv \mta{J}\ C\ (\mta{unrepr}\ w)\ e
  \end{alignat*}
  \end{minipage}%
  \caption{Coherence of the representation operators with substitutions, $\Pi$, $\mta{Id}$,
  and universes . The terms $\MRepr\ (\El{t})$, $\Mrepr\ (\pi_2 \sigma)$ and
  $\Munrepr\ (\pi_2 \sigma)$ do not reduce.}
  \label{fig:lambdaind-repr-coherence-pi-univ}
\end{figure}

So far the representation operators do not really do much other than commute
with almost everything in the syntax. In order to make
them useful, we need to define how they compute when they encounter data types
which have a defined representation in the global context.
We use a decidable relation $R \in_i \Sigma'$ to mean that $R :
\mta{Rep}\ \Sigma\ I$ is the representation of an item $I : \mta{Item}\ \Sigma$
where $i : I \in \Sigma'$.
This relation is a proposition, so it is proof-irrelevant. Furthermore, it is stable under
substitutions and global weakening, because each item can only be represented once in a global context.
In the following rules, $r : \mta{datarep}\ (R, r, Q) \in_i \Sigma$.

Firstly, we define the reduction that occurs when a type $\mta{D}\ i$ is represented,
\begin{equation}
  \mta{Repr-D}_i : \forall r.\ \MRepr\ (\mta{D}\ i) = \mta{El}\ R@ \,, \label{eq:lambdaind-Repr-D}
\end{equation}
yielding the carrier $R$ of the inductive algebra that represents it (after
converting it from a function into the universe to a type family).

Next, we add a rule for representing constructors, albeit in propositional form, where
\begin{equation}
\mta{repr-C}_i : \forall r.\ \Tm\ (\Sigma, \Delta)\ (\mta{Id}\ (\Mrepr\ (\mta{C}\ a))\ (\emb{r}\ a^\mta{Repr}))  \label{eq:repr-ci}
\end{equation}
Here, the operation $\_^{\mta{Repr}}$ is used to apply the term former
$\mta{repr}$ to the recursive part of the arguments $a$. The full construction
can be found in \cref{app:reprs} of the appendix

One might be tempted to make this equality definitional too. Unfortunately, this
would render conversion checking undecidable, because if one applies
$\mta{unrepr}$ to a term $\Mrepr\ (\mta{C}\ a)$ which has already been reduced
to its representation, $\mta{unrepr}\ (\emb{r}\ a^{\mta{Repr}})$, there is no
clear way to decide that this is convertible to $\mta{C}\ a$ even though the
definitional equality rules would imply that it is (due
to the annihilation of $\mta{repr}$ and $\mta{unrepr}$). There is no
equivalent of $\mta{unrepr}$ for types, so \eqref{eq:lambdaind-Repr-D} preserves
the decidability of conversion checking.


We can also add a propositional equality rules for representing eliminators.
First, representing an eliminator just applies $\mta{repr}$ to the motive and methods:
\begin{align*}
&\mta{repr-E}_i : \forall r.\ \Tm\ (\Sigma, \Delta)\ (\mta{Id}\ (\Mrepr\ (\mta{E}\ m))\ (\mta{E}\ m^\mta{Repr})) \\
&\mta{unrepr-E}_i : \forall r.\ \Tm\ (\Sigma, \Delta)\ (\mta{Id}\ (\Munrepr\ (\mta{E}\ m))\ (\mta{E}\ m^\mta{Unrepr}))
\end{align*}
Additionally, eliminating something using $\mta{E}$ should be the same as
eliminating the representation of that thing using the represented eliminator $Q$:
\begin{align*}
&\mta{repr-equiv-E}_i : \forall r.\ \Tm\ (\Sigma, \Delta)\ (\mta{Id}\ (\mta{E}\ m)\ (s.\ (\emb{Q}_0\ m^{\mta{Repr*}})[\Msub{\mta{repr}\ s}])))
\end{align*}
Above we use more auxilliary definitions which represent the carriers of
algebras, as well as displayed algebras (appendix \cref{app:reprs}):
\begin{align*}
\_^{\mta{Repr}} &: \mta{Algebra}\ T\ X \to \mta{Algebra}\ T\ (\mta{Repr}\ X) \\
 \_^{\mta{Repr}} &: \mta{DispAlgebra}\ a\ M \to \mta{DispAlgebra}\ a\ (\MRepr\ M) \\
 \_^{\mta{Repr}*} &: \mta{DispAlgebra}\ a\ M \to \mta{DispAlgebra}\ a^{\mta{Repr}}\ (p\ x .\ M[\Msub{p;\mta{unrepr}\ x}])
\end{align*}

We do not need an additional equality rule for representing function definitions
as this is given by the equality proof $p$ in the definition of a
representation $\mta{defrepr}\ t\ p$, when accounting for the definitional
equality between a definition and its implementation.

\subsection{Translating representations away}

We now define a translation step $\R$ from $\lambdarep$ to
$\lambdaind^{\lang{ext}}$, meant to be applied during the compilation process.
More specifically, the translation target is the extensional flavour of
$\lambdaind$ by adding the equality reflection rule. General undecidability of
conversion is not a problem because type checking is decidable for
$\lambdarep$\footnote{Not formalised in this paper.} and we only need to apply this
transformation after type checking, on fully-typed terms. The translation is
defined over the syntax of $\lambdarep$ \cite{Boulier2017-cm} such that
definitional equality is preserved. Overall, $\R$ preserves the structure of
$\lambdarep$, but maps constructs to their `terminal' representations.
First, we define a translation of global contexts $\R : \Glob_\rep \to \Glob_\ind^\lang{ext}$ as
\[
\R\ \bullet := \bullet \qquad \R\ (\Sigma \rhd I) := \R \Sigma \rhd \R I \qquad \R\ (\Sigma \unrhd I \ R) := \R \Sigma
\]
which erases all items with defined representations.
This utilises a translation of items $\R : \Item_\rep\ \Sigma \to \Item_\ind^\lang{ext}\ \R
\Sigma$ which simply recurses on all subterms with $\R$.
Types are translated as
\begin{align*}
  & \R : \Ty_\rep\ (\Sigma, \Delta)\ \to \Ty_\ind^\lang{ext}\ (\R \Sigma, \R \Delta) \\
  & \R\ (\mta{D}\ i) := \begin{cases}
  \R\ (\mta{El}\ R@) & \text{if $\mta{datarep}\ (R, r, Q) \in_i \Sigma$} \\
  \mta{D}\ \R i & \text{otherwise}
  \end{cases}  \qquad \R\ (\MRepr\ T) := \R T \\
  & \text{(otherwise recurse on all subterms with $\R$)} \,.
\end{align*}
The definitional equality rules of $\mta{Repr}$ and $\mta{D}$ are mirrored, but $\R$ is now applied
to all subterms.
Similarly, terms are translated as
\begin{align*}
  & \R : \Tm_\rep\ (\Sigma, \Delta)\ T \to \Tm_\ind^\lang{ext}\ (\R \Sigma, \R \Delta)\ \R T \\[1em]
  &\R\ (\mta{C}_i\ a) = \begin{cases}
      \emb{\R r}\ \R a & \text{if}\ \mta{datarep}\ (R, r, Q) \in_i \Sigma \\
      \mta{C}_{\R i}\ \R a & \text{otherwise}
  \end{cases} \\
  &\R\ (\mta{E}_i\ m) = \begin{cases}
      \emb{\R Q}_0\ \R m & \text{if}\ \mta{datarep}\ (R, r, Q) \in_i \Sigma \\
      \mta{E}_{\R i}\ \R m & \text{otherwise}
  \end{cases} \\
  &\R\ (\mta{F}_i) = \begin{cases}
        \R t & \text{if}\ \mta{defrep}\ t\ p \in_i \Sigma \\
        \mta{F}_{\R i} & \text{otherwise}
    \end{cases}  \qquad \R\ (\Mrepr\ t) ,\ \R\ (\Munrepr\ t) := \R t \\[1em]
  & \R\ (\mta{repr-C}_i\ a),\ \R\ (\mta{repr-E}_i\ m),\ \R\ (\mta{unrepr-E}_i\ m),\ \R\ (\mta{repr-equiv-E}_i\ m) \text{ := } \mta{refl} \\[1em]
  & \text{(otherwise recurse on all subterms with $\R$)}
\end{align*}
Constructor, eliminator and definition translations mirror the equality rules in
\cref{sub:lambdarep}, but apply $\R$ to all subterms rather than only the
recursive occurrences of the data type being represented. As a result, all of
the propositional equality constructors are translated to reflexivity, since
after applying $\R$ both sides are identical.

The equality constructors of the syntax of $\lambdarep$ must also be translated.
The base equalities of the theory are preserved by their counterparts in
$\lambdaind^\lang{ext}$. The coherence rules for representation operators
(\cref{fig:lambdaind-repr-coherence-pi-univ}) are preserved by metatheoretic
reflexivity on the other side, since all representation operators are erased.
Finally, coherence rules for definitions $\mta{F}$ and eliminators $\mta{E}$ are
preserved by reflecting the propositional coherence rules provided by their
defined representations:
\begin{align*}
& \mta{ap}_\R\ (\mta{E-id}_i\ m) :=
\begin{cases}
    \mta{reflect}\ \emb{\R Q}_1\ \R m & \text{if}\ \mta{datarep}\ (R, r)\ Q \in_i \Sigma \\
    \mta{E-id}_{\R i}\ \R m & \text{otherwise}
    \end{cases} \\
    & \mta{ap}_\R\ (\mta{F-id}_i) :=
    \begin{cases}
        \mta{reflect}\ \R p & \text{if}\ \mta{defrep}\ t\ p \in_i \Sigma \\
        \mta{F-id}_{\R i} & \text{otherwise}
        \end{cases} \\
& \text{(otherwise recurse on all equality constructors with $\mta{ap}_\R$)}
\end{align*}

\begin{theorem}
    $\R$ preserves typing and definitional equality: $(t_1, t_2 : \Tm_{\ind}\ \Gamma\ A) \to t_1 = t_2 \to \R t_1 = \R t_2$.
    \begin{proof}
        By $\mta{ap}_\R$.
    \end{proof}
\end{theorem}
$\R$ is not injective in general, because two distinct (by their location in the
global context) data types might be defined to have the same representation.

\begin{theorem}
    $\R$ is a left-inverse of the evident inclusion $i : \lambdaind \hookrightarrow \lambdarep$:
    \[
        (t : \Tm_{\ind}\ \Gamma\ A) \to \R(i t) = t \,.
    \]
    \begin{proof}
        The inclusion produces global contexts in $\lambdarep$ without the $\unrhd$ constructor. Thus no
        items have defined representations. Also, the action of $\R$ on
        the image of $i$ does not invoke the equality reflection rule. With that
        constraint, and by induction on the syntax, $\R \circ i$ is the identity
        function on $\lambdaind$.
    \end{proof}
\end{theorem}

\subsection{Computational irrelevance}\label{sub:irr}

In order to reason about computational irrelevance, we assume that there is
an additional program extraction step $\mathcal{E}$ from $\lambdaind$ into some
simply-typed calculus, denoted by vertical bars $|x|$. As opposed to
$\R$, $\mathcal{E}$ operates on the unquotiented syntax of $\lambdaind$. This
can be justified by interpreting the quotient-inductive constructions from
before into setoids \cite{Kovacs2022-vb}. This kind of transformation is used
because we might want to compile two definitionally equal terms differently. For
example, we might not always want to reduce function application redexes. We
will use the \texttt{monospace} font for terms in $\lambda$.

\begin{definition}
    A function $f : \mta{Tm}\ \Gamma\ (\Pi\ A\ B)$, is \emph{computationally irrelevant} if
    $|\R A| = |\R B|$ and $|\R f| = \texttt{id}$.
\end{definition}

\begin{theorem}
	The type former $\MRepr{}$ is injective up to internal isomorphism, i.e.
	\begin{equation}
	\Tm\ \Gamma\ (\mta{Id}\ (\mta{Repr}\ T)\ (\mta{Repr}\ T')) \to \Tm\ \Gamma\ (\mta{Iso}\ T\ T')
	\end{equation}
	Moreover, this isomorphism is computationally irrelevant.
	\begin{proof}
	For the input proof $p$, the forward direction is
	$\lambda x.\ \Munrepr_{T'}\ (\mta{J}\ \mta{id}\ (\Mrepr\ x)\ p)$
	and the backward direction is
	$\lambda x.\ \Munrepr_{T}\ (\mta{J}\ \mta{id}\ (\Mrepr\ x)\ (\mta{sym}\
	p))$. The coherence holds definitionally by
    \begin{align*}
	&\Munrepr_{T'}\ (\mta{J}\ \mta{id}\ (\Mrepr\ (\Munrepr_{T}\ (\mta{J}\ \mta{id}\ (\Mrepr\ x)\ (\mta{sym}\ p))))\ p) \\
	&= \Munrepr_{T'}\ (\mta{J}\ \mta{id}\ (\mta{J}\ \mta{id}\ (\Mrepr\ x)\ (\mta{sym}\ p))\ p) \text{ by }{\mta{reprl}} \\
    &= \mta{J}\ \mta{id}\ (\mta{J}\ \mta{id}\ x\ (\mta{sym}\ p))\ p \text{ by }{\mta{unrepr-J}\times 2 + \mta{reprr}} \\
    &= x \text{ by }{(\mta{uip} + \mta{J-elim})\times2} \,,
    \end{align*}
	and similarly for the other side. After applying $\R$, we get $\lambda x.\
	\mta{J}\ \mta{id}\ x\ p =_{\mta{uip}+\mta{J-elim}} \lambda x.\ x$ on both sides.
	\end{proof}
\end{theorem}

Consider extending our languages with usage-aware
subset $\Sigma$-types
\[
\{ \_ \mid \_ \} : (A : \Ty\ \Gamma) \to \Ty\ (\Gamma \rhd A) \to \Ty\ \Gamma
\]
in such a way that $\MRepr$ and $\R$ preserve them, but the extraction
step erases the right component, i.e. $|\{A \mid B\}| = |A|$, $|(x, y)| = |x|$ and $|\pi_1 x| =
|x|$.\footnote{This can be implemented using quantitative type theory for example.}
Suppose we have an inductive family $G : \mta{data}\ (\bullet \rhd I)\ T_G
\in \Sigma$ over some index type $I$, and an inductive type $F : \mta{data}\ \bullet\
T_F \in \Sigma$ such that $G$ is represented by a refinement $f : \Tm\
(\Sigma,\bullet)\ (\Pi\ (\mta{D}\ F)\ I)$ of $F$,
\[
    \mta{datarep}\ (i.\ \{ x : \mta{D}\ F \mid \mta{Id}\ (f\ x)\ i \}, r, Q) \in_G \Sigma \,.
\]
Then, we can construct computationally irrelevant functions
\begin{align*}
&\begin{aligned}
&\mta{forget}_i : \Tm\ \Gamma\ (\Pi\ (\mta{D}\ G)[i]\ (\mta{D}\ F)) \\
&\mta{forget}_i = \lambda g.\ \pi_1\ (\mta{repr}\ g)
\end{aligned} \quad \begin{aligned}
&\mta{remember} : \Tm\ \Gamma\ (\Pi\ (x : \mta{D}\ F)\ (\mta{D}\ G)[f\ x]) \\
&\mta{remember} = \lambda x.\ \mta{unrepr}\ (x, \mta{refl}) \,.
\end{aligned}
\end{align*}
Clearly $|\R\ \mta{forget}_i| = |\R\ \mta{remember}| = \texttt{id}$.
